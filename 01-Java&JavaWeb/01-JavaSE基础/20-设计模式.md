# 设计模式

## 1. 单例设计模式（框架中会经常出现单例类）
### 1.1. 单例的特点

1. 类在程序的运行过程中只有一个对象(实例)。
2. 私有构造方法，不能让外界创建该类的对象。
3. 类必须提供一个静态公共方法返回该类的对象。

### 1.2. 单例实现方式(饿汉式)

- 当类加载时，就立即创建该单例对象。
- 饿汉式是线程安全的。
- 实现步骤：
    1. 定义一个静态的对象成员变量
    2. 要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。外界就可以直接new对象
    3. 定义一个静态的成员方法，用来获取创建好的对象成员，一般命名用 `getInstance()`

Code Demo:(饿汉式单例)

```java
/**
 *  单例类
 *  饿汉式：当类加载时，就立即创建该单例对象。
 */
public class MoonZero {
    // 定义一个静态的成员变量
    private static MoonZero mz = new MoonZero();

    // 要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。
    private MoonZero() {}

    // 定义一个静态的成员方法，用来获取创建好的成员对象
    public static MoonZero getInstance() {
        return mz;
    }
}
```

### 1.3. 单例实现方式(懒汉式)

- 当外界第一次要使用该类的对象时，如果还没有创建出来，则创建该单例对象。
- 懒汉式是线程不安全的，要处理线程安全问题。从性能上考虑，一般选择同步代码块去处理线程安全问题。
- 实现步骤：
    1. 定义一个静态的对象成员变量
    2. 要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。外界就可以直接new对象
    3. 定义一个静态的成员方法，用来获取对象成员，一般命名用 `getInstance`
    4. 需要考虑线程安全的问题。
    5. 第一种是使用同步方法，增加 synchronized，在方法内再进行判断对象是否为空，如果为空，就直接创建。
    6. 第二种是使用同步代码块，一开始先判断对象是否为空，为了性能的问题，为了后面的线程不再需要加锁；同步对象写，`MoonZero.class` 保证锁对象被所有对象共享；

注：同步方法块中的也要做if判断，因为可能在`mz==null`前已经多个线程进来，如果不做判断，当前一个线程创建对象后，其他线程也可以抢到锁再进入创建对象。

Code Demo:(懒汉式单例)

```java
/**
 *	单例类
 *	懒汉式：当外界第一次要使用该类的对象时，如果还没有创建出来，则创建该单例对象。
 */
public class MoonZero {
    // 定义一个静态的对象成员变量
    private static MoonZero mz;

    // 要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。
    private MoonZero() {}

    // 定义一个静态的成员方法，用来获取创建好的成员对象(同步代码块)
    public static MoonZero getInstance1() {
        // 判断如果之前对象不存在就进行创建
        // 再加个判断，为了性能的问题，为了后面的线程不再需要加锁
        if (mz == null) {
            // 为了解决线程安全问题，需要同步代码块，MoonZero.class保证锁对象被所有对象共享
            // 如果在mz==null前已经多个线程进来，所以同步方法块中的if判断不能省略
            synchronized (MoonZero.class) {
                if (mz == null) {
                    mz = new MoonZero();
                }
            }
        }
        return mz;
    }

    // 定义一个静态的成员方法，用来获取创建好的成员对象(同步方法)
    public static synchronized MoonZero getInstance2() {
        // 判断如果之前对象不存在就进行创建
        if (mz == null) {
            mz = new MoonZero();
        }
        return mz;
    }
}
```

### 1.4. 会使用到单例类的案例

- 一个类只要一个对象的时候
- 视频播放器，音频播放器
- 数据库的连接
- 设置信息

### 1.5. 其他小问题

开发中一般使用饿汉式，面试的时候使用懒汉式

## 2. 模板方法设计模式

### 2.1. 定义与特点

模板方法（Template Method）模式的定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

模式的主要优点如下：

1. 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
2. 它在父类中提取了公共的部分代码，便于代码复用。
3. 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。

该模式的主要缺点如下：

1. 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
2. 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
3. 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。


## 3. 网络参考资料

- [设计模式内容聚合](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487936&idx=2&sn=02c48b88fa45a32e55b99fa0be610a29&chksm=ebd62eecdca1a7faccf9f26d17bd2108e1b8939421640f71f1ebf5f14b621448ac05ad168a00&mpshare=1&scene=1&srcid=#rd)
- [Java设计模式：23种设计模式全面解析（超级详细）](http://c.biancheng.net/design_pattern/)
