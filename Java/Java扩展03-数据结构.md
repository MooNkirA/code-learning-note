# Java扩展 - 数据结构

## 1. 数据结构概述

数据结构指数据的存储、组织方式。因此良好的数据结构对于程序的运行至关重要，尤其是在复杂的系统中，设计优秀的数据结构能够提高系统的灵活性和性能。

数据存储的常用结构有：**数组、栈、队列、链表**、二叉树、红黑树、散列表和位图。

![](images/208731014247601.png)

## 2. 数组结构

- **查询元素快**：通过索引，可以快速访问指定位置的元素
- **增删元素慢**：
    - 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。
    - 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。

## 3. 堆栈结构（stack）

### 3.1. 概述

栈（Stack）又名堆栈，是允许在同一端进行插入和删除操作的特殊线性表。存储的元素是**先进后出**（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）(First In Last Out/FILO)。

栈的入口、出口的都是栈的顶端位置。允许进行插入和删除操作的一端叫作栈顶（Top）。另一端叫作栈底（Bottom），栈底固定，栈顶浮动。

以下是栈结构一些专用名词：

- **空栈**：栈中的元素个数为零时。
- **进栈（压栈）**：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
- **出栈（弹栈、退栈）**：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。

![](images/20200520232927655_23342.png)

### 3.2. 栈结构的核心方法

要实现一个栈，需要先实现以下核心方法：

- `push()`：向栈中压入一个数据，先入栈的数据在最下边。
- `pop()`：弹出栈顶数据，即移除栈顶数据。
- `peek()`：返回当前的栈顶数据。

### 3.3. 栈的 Java 实现

> TODO: 待整理

## 4. 队列结构（queue）

### 4.1. 概述

队列，是一种只允许在表的前端进行删除操作且在表的后端进行插入操作的线性表。存储的元素是**先进先出**（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）（First In First Out/FIFO）。

队列结构一些专用名词：

- **队尾**：执行插入操作的一端
- **队头**：执行删除操作的一端
- **空队列**：没有元素的队列
- **入队**：在队列中插入一个队列元素
- **出队**：从队列中删除一个队列元素

队列的入口、出口各占一侧，并且只允许在队头删除，在队尾插入，就可以实现先进先出的效果。

![](images/20200520232804816_17550.jpg)

### 4.2. 队列结构的核心方法

要实现一个队列，需要先实现以下核心方法：

- `add()`：向队列的尾部加入一个元素（入队），先入队列的元素在最前边。
- `poll()`：删除队列头部的元素（出队）。
- `peek()`：取出队列头部的元素。

### 4.3. 队列的 Java 实现

> TODO: 待整理

## 5. 链表结构（link）

### 5.1. 概述

链表是由一系列节点，通过地址进行连接而组成的数据结构，节点可以在运行过程中动态生成。

> Notes: 链表中的每一个元素都叫作一个节点

为了表示每个数据元素与其直接后继数据元素之间的逻辑关系，每个节点存储包括两部分内容：

1. 存储元素本身的数据域
2. 存储直接后继数据元素的信息（即直接后继数据元素的存储地址的指针域）

#### 5.1.1. 链表的特点

链表通过一组存储单元存储线性表中的数据元素，这组存储单元可以是连续的，也可以是不连续的。由于节点包含了**元素数据**与**下一个元素的地址**这两部分信息，因此有以下特点：

- **查询元素慢**：想查找某个元素，从链表头或链表尾开始查找，需要通过连接的节点，依次向后一个个遍历查询指定元素。
- **增删元素快**：增删元素不需要移动元素的位置，只需要修改元素记录连接下个元素的地址值即可。

#### 5.1.2. 链表的分类

链表有 3 种不同的类型：单向链表、双向链表及循环链表。

![](images/20200520233047741_32691.jpg)

### 5.2. 单向链表

#### 5.2.1. 组成结构

单向链表（又称单链表）是链表的一种，其特点是链表的链接方向是单向的，访问链表时要从头部开始顺序读取。单向链表是链表中结构最简单的。一个单向链表的节点（Node）可分为两部分：

- 第1部分为数据区（data），用于保存节点的数据信息
- 第2部分为指针区，用于存储下一个节点的地址，最后一个节点的指针指向null。

![](images/414085614240270.png)

#### 5.2.2. 单向链表的操作

- 查找：单向链表只可向一个方向遍历，一般在查找一个节点时需要从单向链表的第1个节点开始依次访问下一个节点，一直访问到需要的位置。
- 插入：对于单向链表的插入，只需将当前插入的节点设置为头节点，将 Next 指针指向原来的头节点即可。

![](images/6395914236825.png)

- 删除：对于单向链表的删除，只需将该节点的上一个节点的 Next 指针指向该节点的下一个节点，然后删除该节点即可。

![](images/189285914232579.png)

#### 5.2.3. 单向链表的 Java 实现

> TODO: 待整理

### 5.3. 双向链表

#### 5.3.1. 组成结构

双向链表的每个数据节点中都有 `Prev` 和 `Next` 两个指针，分别指向其上一个节点和下一个节点。因此双向链表中的任意一个节点都很方便访问其前后的节点，出方便从两个方向遍历并处理节点的数据。

![](images/104564415250459.png)

#### 5.3.2. 双向链表的 Java 实现

> TODO: 待整理

### 5.4. 循环链表

循环链表的链式存储结构的特点是：链表中最后一个节点的指针域指向头节点，整个链表形成一个环。

![](images/127025315248063.png)

循环节点的实现和单向链表十分相似，只是在链表中，尾部元素的 Next 指针不再是 null，而是指向头部节点，其他实现和单向链表相同。

## 6. 散列表（Hash Table）

### 6.1. 概述

散列表（Hash Table，也叫作哈希表）是根据数据的关键码值（Key-Value对）对数据进行存取的数据结构。

散列表通过映射函数把关键码值（key）映射到表中的一个位置来加快查找。这个映射函数叫作散列函数，存放记录的数组叫作散列表。

![](images/588292016245565.png)

散列表算法通过在数据元素的存储位置和它的关键字（可用 key 表示）之间建立一个确定的对应关系，使每个关键字和散列表中唯一的存储位置相对应。在查找时只需根据这个对应关系找到给定关键字在散列表中的位置即可，真正做到一次查找命中。

### 6.2. 常用的构造散列函数

常用的构造散列函数有如下几种：

- 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即 `h(key) = key` 或 `h(key)=a×key+b`，其中a和b为常数。
- 平方取值法：取关键字平方后的中间几位为散列地址。
- 折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。
- 除留余数法：取关键字被某个不大于散列表长度 m 的数 p 除后所得的余数为散列地址， 即 `h(key)=key/p`，其中 `(p≤m)`。
- 随机数法：选择一个随机函数，取关键字的随机函数值作为其散列地址，即 `h(key)=random(key)`。
- Java HashCode实现：在 Java 中计算 HashCode 的公式为 f(key) = s[0] × 31<sup>n-1</sup>+s[1] × 31<sup>n-2</sup> +...+s[n-1]。具体实现如下：

### 6.3. Hash的应用

## 7. 待学习与整理

- 二叉排序树
- 红黑树
- 位图
