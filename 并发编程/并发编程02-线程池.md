# 并发编程（基础篇）- 线程池

## 1. 线程池简介

### 1.1. 线程池的概念

线程池是 JDK 1.5 后的新特性，是用来创建和管理线程对象的容器。线程池做的工作主要是管理线程组，控制运行的线程的数量及其运行状态。

线程池主要特点是：**线程复用、控制最大并发数、管理线程**。

### 1.2. 线程池的工作原理

Java 线程池的工作原理为：JVM 先根据用户的参数创建一定数量的可运行的线程任务，并将线程任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量（由用户设置），则**超出数量的线程排队等候**，等其它线程执行完毕，线程池调度器发现队列中有可用的线程时，再从队列中取出任务来执行。

#### 1.2.1. 线程复用

在 Java 中，每个 `Thread` 类都有一个 `start` 方法。在程序调用 `start` 方法启动线程时，Java 虚拟机会调用该类的 `run` 方法。`Thread` 类的 `run` 方法中其实调用了 `Runnable` 对象的 `run` 方法，例如定义继承 `Thread` 类，在循环中不断传递进来的 `Runnable` 对象来创建线程，再调用 `start` 方法开启线程，就相当于不断执行 `run` 方法中的代码。因此可以将在循环方法中不断获取的 `Runnable` 对象存放在 Queue 中，当前线程在获取下一个 `Runnable` 对象之前可以是阻塞的，这样既能有效控制正在执行的线程个数，也能保证系统中正在等待执行的其他线程有序执行。

以下就是简单实现了一个线程池，达到了线程复用的效果。

### 1.3. 使用线程池的好处

- 降低资源消耗：重用存在的线程的复用，避免频繁创建和销毁线程对象会带来过大的系统开销。
- 提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
- 附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。

综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。

### 1.4. 线程池的组成

一般的线程池主要分为以下 4 个组成部分：

1. 线程池管理器：用于创建并管理线程池
2. 工作线程：线程池中执行具体任务的线程
3. 任务接口：每个任务必须实现的接口，用于工作线程调度和执行策略。*注：只有线程实现了该接口，线程中的任务才能够被线程池调度。*
4. 任务队列：用于存放待处理的任务，提供一种缓冲机制。新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。

## 2. 线程池的状态

- `RUNNING`：这是最正常的状态，接受新的任务，处理等待队列中的任务。
- `SHUTDOWN`：不接受新的任务提交，但是会继续处理等待队列中的任务。
- `STOP`：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。
- `TIDYING`：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 `TIDYING` 状态时，会执行钩子方法 `terminated()`。
- `ERMINATED`：`terminated()` 方法结束后，线程池的状态就会变成这个。

## 3. Java 内置线程池

### 3.1. Executor 接口

Java 里面线程池的顶级接口是 `Executor`，但是严格意义上讲 `Executor` 并不是一个线程池，而只是一个执行线程的框架，真正的线程池接口是 `ExecutorService`。该框架主要涉及 Executor，Executors，ExecutorService，ThreadPoolExecutor，Callable 和 Future、FutureTask 这此类。

- `Executor` 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架
- `Executors` 是一个工具类，提供不同方法按照相关的需求创建了不同的线程池
- `ExecutorService` 接口继承了 `Executor` 接口并进行了扩展，提供了更多的方法能获得任务执行的状态并且可以获取任务的返回值。
- `ThreadPoolExecutor` 创建自定义线程池的核心类
- `Future` 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 `get()` 方法获取计算的结果

### 3.2. ExecutorService 接口

`ExecutorService` 接口是 java 内置的线程池接口，继承了 `Executor` 接口。

```java
public interface ExecutorService extends Executor
```

#### 3.2.1. 接口常用方法

```java
void shutdown();
```

- 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。

```java
List<Runnable> shutdownNow();
```

- 停止所有正在执行的任务，暂停处理正在等待的任务，并返回等待执行的任务列表。

```java
<T> Future<T> submit(Callable<T> task);
```

- 执行带返回值的任务，返回一个 `Future` 对象。

```java
Future<?> submit(Runnable task);
```

- 执行 `Runnable` 任务，并返回一个表示该任务的 `Future`。

```java
<T> Future<T> submit(Runnable task, T result);
```

- 执行 `Runnable` 任务，并返回一个表示该任务的 `Future`。

#### 3.2.2. 示例

```java
public class ExecutorServiceDemo {

    @Test
    public void shutdownTest() {
        // 使用工厂类获取线程池对象
        ExecutorService es = Executors.newSingleThreadExecutor();
        // 提交任务
        for (int i = 1; i <= 10; i++) {
            es.submit(new ExecutorServiceDemoRunnable(i));
        }
        // 关闭线程池,仅仅是不再接受新的任务,以前的任务还会继续执行
        es.shutdown();
        es.submit(new ExecutorServiceDemoRunnable(888)); // 不能再提交新的任务了
    }

    @Test
    public void shutdownNowTest() {
        // 使用工厂类获取线程池对象
        ExecutorService es = Executors.newSingleThreadExecutor();
        // 提交任务
        for (int i = 1; i <= 10; i++) {
            es.submit(new ExecutorServiceDemoRunnable(i));
        }
        // 立刻关闭线程池，如果线程池中还有缓存的任务，没有执行，则取消执行，并返回这些任务
        List<Runnable> runnables = es.shutdownNow();
        System.out.println(runnables);
    }
}

/**
 * 任务类,包含一个任务编号,在任务中,打印出是哪一个线程正在执行任务
 */
class ExecutorServiceDemoRunnable implements Runnable {
    private final int id;

    public ExecutorServiceDemoRunnable(int id) {
        this.id = id;
    }

    @Override
    public void run() {
        // 获取线程的名称并输出
        String name = Thread.currentThread().getName();
        System.out.println(name + "执行了任务..." + id);
    }

    @Override
    public String toString() {
        return "ExecutorServiceDemoRunnable{id=" + id + "}";
    }
}
```

### 3.3. ScheduledExecutorService 接口

```java
public interface ScheduledExecutorService extends ExecutorService
```

`ScheduledExecutorService` 接口继承了 `ExecutorService` 接口，具备了延迟运行或定期执行任务的能力

**`ScheduledExecutorServic`e 常用方法**：

```java
public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);
```

- 延迟时间单位是 unit，数量是 delay 的时间后执行 Callable 接口的逻辑。

```java
public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);
```

- 延迟时间单位是 unit，数量是 delay 的时间后执行 Runnable 接口的逻辑。

```java
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
```

- 延迟时间单位是 unit，数量是 initialDelay 的时间后，每间隔 period 时间重复执行一次 Runnable 接口的逻辑。

```java
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
```

- 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟（delay）。

### 3.4. ThreadPoolExecutor

#### 3.4.1. 构造方法

ThreadPoolExecutor 类的构造方法及参数说明

```java
public ThreadPoolExecutor(int corePoolSize, // 核心线程数
                          int maximumPoolSize, // 最大线程池大小，也就是线程池总的大小
                          long keepAliveTime, // 线程最大空闲时间
                          TimeUnit unit, // 时间单位
                          BlockingQueue<Runnable> workQueue, // 线程等待队列
                          ThreadFactory threadFactory, // 线程创建工厂
                          RejectedExecutionHandler handler // 拒绝策略
                        )
```

#### 3.4.2. 创建线程池的核心构造参数

可以通过配置不同的参数，创建出行为不同的线程池，以下是 `ThreadPoolExecutor` 构造函数的重要参数：

- `corePoolSize`：线程池的核心线程数，线程数定义了最小可以同时运行的线程数量
- `maximumPoolSize`：线程池允许存在的最大工作线程数
- `workQueue`：任务执行前保存任务的队列，保存由 `execute` 方法提交的 `Runnable` 任务。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。

其他参数：

- `keepAliveTime`：超过核心线程数时闲置线程的存活时间。即当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime` 配置的时间才会被回收销毁
- `unit`：`keepAliveTime` 参数的时间单位
- `threadFactory`：为线程池提供创建新线程的线程工厂
- `handler`：线程池任务队列超过 `maximumPoolSize` 之后的拒绝策略

#### 3.4.3. ThreadPoolExecutor 拒绝(饱和)策略

如果当前同时运行的线程数量达到线程池中最大线程数量，并且阻塞队列也已经被放满了线程时，则说明线程池的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务。

ThreadPoolExecutor 定义一些拒绝策略来处理新添加的线程任务：

- `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException` 来拒绝新任务的处理。
- `ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务。不会丢弃任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果应用程序可以承受此延迟并且不能丢弃任何一个任务请求的话，可以选择这个策略。
- `ThreadPoolExecutor.DiscardPolicy`：不处理当前新任务，直接丢弃掉。
- `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃线程队列中最早的未处理的任务请求，并尝试提交当前任务。

例如：Spring 通过 `ThreadPoolTaskExecutor` 或者直接通过 `ThreadPoolExecutor` 的构造函数创建线程池的时候，当不指定 `RejectedExecutionHandler` 饱和策略的话来配置线程池的时候默认使用的是 `ThreadPoolExecutor.AbortPolicy`。在默认情况下，`ThreadPoolExecutor` 将抛出 `RejectedExecutionException` 来拒绝新来的任务，这代表将丢失对这个任务的处理。对于可伸缩的应用程序，建议使用 `ThreadPoolExecutor.CallerRunsPolicy`。当最大池被填满时，此策略可以提供可伸缩队列。

#### 3.4.4. 自定义拒绝策略

上面默认的拒绝策略均实现了 `RejectedExecutionHandler` 接口，若无法满足实际需要，可以自行扩展 `RejectedExecutionHandler` 接口来实现拒绝策略，并捕获异常来实现自定义拒绝策略。

以下示例实现一个自定义拒绝策略 `DiscardOldestNPolicy`，该策略根据传入的参数丢弃最老的 N 个线程，以便在出现异常时释放更多的资源。具体参考代码如下：

![](images/183920011239493.png)

## 4. Executors 工具类创建各种类型的线程池

`Executors` 提供了一系列工厂方法用于创建线程池的工具类，该类中提供了各种静态方法创建不同类型的线程池（即不同的 `ExecutorService` 接口的实现）。

> 引用《阿里巴巴 Java 开发手册》中关于线程池的内容：
>
> 【强制】线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：`Executors` 返回的线程池对象的弊端如下：
>
> 1. `FixedThreadPool` 和 `SingleThreadPool`：允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM
> 2. `CachedThreadPool`：允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量的线程，从而导致 OOM

### 4.1. newCachedThreadPool

```java
public class Executors {
    // 创建一个默认的线程池对象，里面的线程可重用，且在第一次使用时才创建
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }

    // 线程池中的所有线程都使用 ThreadFactory 来创建，这样的线程无需手动启动，自动执行
    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>(),
                                      threadFactory);
    }
    // ...省略
}
```

`newCachedThreadPool` 用于创建一个缓存线程池。**调用 execute 创建新线程时，如果有可用线程，则重用以前构造的线程；如果现有线程没有可用的，则创建一个新线程并添加到池中，终止并从缓存中移除那些(keepAliveTime)超过默认的 60 秒未被使用的线程**。因此长时间保持空闲的线程池不会占用任何资源。

一般在创建线程时需要执行申请 CPU 和内存、记录线程状态、控制阻塞等多项工作，复杂且耗时。对于执行很多短期异步任务的程序而言，这种线程池很大程度地重用线程，从而提高程序性能。

### 4.2. newFixedThreadPool

```java
public class Executors {
    // 创建一个可重用固定线程数的线程池
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }

    // 创建一个可重用固定线程数的线程池且线程池中的所有线程都使用 ThreadFactory 来创建
    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>(),
                                      threadFactory);
    }
    // ...省略
}
```

`newFixedThreadPool` 用于创建一个**可重用固定线程数量的线程池**，并将线程资源存放在共享的无界队列中循环使用。

在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交新任务，则在有可用线程之前，新任务将在队列中等待，直到有可用的线程资源；如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。

### 4.3. newSingleThreadExecutor

```java
public class Executors {
    // 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }

    // 创建一个使用单个 worker 线程的 Executor，且线程池中的所有线程都使用 ThreadFactory 来创建
    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(),
                                    threadFactory));
    }
    // ...省略
}
```

`newSingleThreadExecutor` 创建一个保证永远有且只有一个可用线程的线程池，**这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去**！此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

### 4.4. newScheduledThreadPool

```java
public class Executors {
    // 创建一个可重用固定线程数的线程池且允许延迟运行或定期执行任务
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }

    // 创建一个可重用固定线程数的线程池且线程池中的所有线程都使用 ThreadFactory 来创建，且允许延迟运行或定期执行
    public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }
    
    // 创建一个单线程执行程序，它允许在给定延迟后运行命令或者定期地执行
    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
    }
    
    // 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行
    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1, threadFactory));
    }
    // ...省略
}
```

`newScheduledThreadPool` 创建了一个可定时调度，核心线程池固定，大小无限的线程池。此线程池支持设置在给定的延迟时间后执行或者周期性执行某个线程任务。如果闲置，非核心线程池会在 `DEFAULT_KEEPALIVEMILLIS` 时间内回收

```java
ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);

scheduledThreadPool.schedule(newRunnable(){
    @Override
    public void run() {
        System.out.println("延迟三秒");
    }
}, 3, TimeUnit.SECONDS);

scheduledThreadPool.scheduleAtFixedRate(newRunnable(){
    @Override
    public void run() {
        System.out.println("延迟 1 秒后每三秒执行一次");
    }
}, 1, 3, TimeUnit.SECONDS);
```

### 4.5. newWorkStealingPool（JDK 1.8 新增）

```java
public class Executors {
    public static ExecutorService newWorkStealingPool(int parallelism) {
        return new ForkJoinPool
            (parallelism,
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }

    public static ExecutorService newWorkStealingPool() {
        return new ForkJoinPool
            (Runtime.getRuntime().availableProcessors(),
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }
    // ...省略
}
```

`newWorkStealingPool` 是 JDK 1.8 新增的线程池类型，创建一个持有足够线程的线程池，达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。

足够的线程指 JDK 根据当前线程的运行需求向操作系统申请足够的线程，以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据 CPU 资源估算并行度的过程。开发者也可以通过带参数的重载方法指定线程的并发数。

### 4.6. 示例



## 5. 线程池使用 – Runnable 接口

### 5.1. 线程池使用Runnable的步骤

1. 通过 Executors 工厂类的静态方法来创建线程池对象：`newFixedThreadPool(int size)`

```java
// 创建线程池对象
ExecutorService tp = Executors.newFixedThreadPool(线程数量);
```

2. 定义Runnable的实现类
3. 重写run方法
4. 创建Rannable实现类对象

```java
MyRunnable mr = new MyRunnable();
```

5. 调用`submit(Runnable task)`提交任务，每次调用该方法就使用线程池中的一条线程，线程完毕后再放回线程池。

```java
tp.submit(mr);
//或者使用匿名内部类的方法传入Runnable对象，调用submit方法
tp.submit(new Runnable(){
    @Override
    public void run(){
        //重写run方法
    }
});
```

6. 销毁线程池
    - `shutdown()`：销毁线程池，要等待线程池中的所有任务执行完成后才销毁。
    - `shutdownNow()`：立即销毁线程池，不管线程池中的任务是否执行完成。（一般比较少用）

### 5.2. 线程池的执行任务过程

1. 刚开始创建好线程池，没有任务要执行，线程池的线程会等待任务
2. 往线程池中提交任务，线程池会派线程执行任务，有些线程没有任务接着等待
3. 如果线程池中的任务比线程多，线程池中个的线程执行任务，后面的任务等待，等到线程执行完任务，空闲的时候，就执行后面的任务
4. 如果所有任务都执行完，线程就等待任务，直到线程池被销毁，这些线程也就销毁

## 6. 线程池使用 – Callable 接口

### 6.1. Callable 接口作用

也是放在子线程上面执行的代码，返回结果并且可能抛出异常的任务。

### 6.2. Callable 接口方法

```java
@FunctionalInterface
public interface Callable<V> {
    /* 计算结果，如果无法计算结果，则抛出一个异常。 */
    V call() throws Exception;
}
```

`Callable` 与 `Runnable` 接口的区别：

- `Runnable` 接口的方法是 `run()`
- `Callable` 接口的方法是 `call()`

### 6.3. call方法的特点

1. 可以有返回值
2. 可以抛出异常

### 6.4. Callable使用线程池的步骤

1. 获取线程池

```java
// 使用Executors的静态方法，定义创建的线程池的线程数量
public static ExecutorService newFixedThreadPool(int nThreads);

// 例如：
ExecutorService tp = Executors.newFixedThreadPool(线程数量);
```

2. 定义 Callable 的实现类
3. 重写 call 方法
4. 创建 Callable 实现类对象

```java
MyCallable mc = new MyCallable();
```

5. 往线程池中调用 submit(Callable<T> task) 提交任务

```java
tp.submit(mc);
// 或者使用匿名内部类的方法传入Callable对象，调用submit方法
tp.submit(new Callable(){
    @Override
    public void call(){
        // 重写run方法
    }
});
```

6. 销毁线程池shutdown();

**注意：可以同时往线程池中提交 `Runnable` 和 `Callable` 任务**

### 6.5. 获取call()方法中的返回值Future

1. 获取 Future 对象

```java
Future<Integer> future = pool.submit(mc);
```

2. 根据Fufutre对象调用get()方法拿到Call方法的返回值

```java
Integer i = future.get();
```

**注：如果多个线程调用了Future的get()方法，下面的线程是同步执行的。因为可能返回值会参与其他的操作，如果异步执行的话，那后面的操作就会出现问题，有些值还没有返回，所以系统规定了是同步执行。**

**Code Demo:(获取call方法返回值Future)**

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/*
	使用线程池方式执行任务,返回1-n的和
*/
public class MoonZero {
    public static void main(String[] args) throws Exception {
        // 创建线程池对象
        ExecutorService pool = Executors.newFixedThreadPool(2);
        // 定义变量接收线程的返回值，使用了匿名对象
        Future<Integer> future1 = pool.submit(new MyCallable(100));
        Integer sum1 = future1.get();
        Future<Integer> future2 = pool.submit(new MyCallable(50));
        Integer sum2 = future2.get();

        System.out.println("1-100的和是：" + sum1);
        System.out.println("1-50的和是：" + sum2);
        // 销毁线程池，这个会等待线程池中所有任务执行完成才销毁
        pool.shutdown();
    }
}

class MyCallable implements Callable<Integer> {
    // 定义一个成员变量用接收统计的n值
    private int num;

    // 定义一个有参的构造方法，用来传入需要统计的参数
    public MyCallable(int num) {
        this.num = num;
    }

    // 重写call方法
    @Override
    public Integer call() throws Exception {
        // 定义一个变量统计总和
        int sum = 0;
        for (int i = 1; i <= num; i++) {
            sum += i;
        }
        return sum;
    }
}
```

## 7. 线程池最常用的提交任务的两种方式

### 7.1. execute()

`ExecutorService.execute()` 方法接收一个 Runnable 实例，它用来执行一个任务

```java
public void execute(Runnable runnable);
```

### 7.2. submit()

`ExecutorService.submit()` 方法返回的是 Future 对象。可以用 `isDone()` 来查询 Future 是否已经完成，当任务完成时，它具有一个结果，可以调用 `get()` 来获取结果。也可以不用 `isDone()` 进行检查就直接调用 get()，在这种情况下， get() 将阻塞，直至结果准备就绪。

```java
public Future<?> submit(Runnable task);
public <T> Future<T> submit(Runnable task, T result);
public <T> Future<T> submit(Callable<T> task);
```

## 8. 线程池的工作流程总结（待确认是否正确）

Java 线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用 `execute()` 方法添加一个任务时，线程池会按照以下流程执行任务：

- 如果正在运行的线程数量少于 `corePoolSize`（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务。
- 如果正在运行的线程数量大于等于 `corePoolSize`，该任务就将被放入阻塞队列中。
- 在阻塞队列已满且正在运行的线程数量少于 `maximumPoolSize` 时，线程池会创建非核心线程立刻执行该线程任务。
- 在阻塞队列已满且正在运行的线程数量大于等于 `maximumPoolSize` 时，线程池将拒绝执行该线程任务并抛出 `RejectExecutionException` 异常。
- 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。
- 在线程处于空闲状态的时间超过 `keepAliveTime` 时间时，正在运行的线程数量超过 `corePoolSize`，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到 `corePoolSize` 大小。

> TODO: 流程图好像有点问题，待修改

![](images/338181510221067.png)
