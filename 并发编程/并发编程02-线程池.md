# 并发编程（基础篇）- 线程池

## 1. 线程池简介

### 1.1. 线程池的概念与原理

JDK 1.5 后的新特性。不再需要开发者自定义容器，直接使用官方提供的即可。一个用来创建和管理线程对象的容器。

线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量**超出数量的线程排队等候**，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：**线程复用、控制最大并发数、管理线程**。

### 1.2. 使用线程池的好处

- 降低资源消耗：重用存在的线程的复用，避免频繁创建和销毁线程对象会带来过大的系统开销。
- 提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
- 附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。

综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。

### 1.3. 线程池的组成

一般的线程池主要分为以下 4 个组成部分：

1. 线程池管理器：用于创建并管理线程池
2. 工作线程：线程池中的线程
3. 任务接口：每个任务必须实现的接口，用于工作线程调度其运行
4. 任务队列：用于存放待处理的任务，提供一种缓冲机制

Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor，Callable 和 Future、FutureTask 这几个类。

- Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架
- Executors 是一个工具类，提供不同方法按照相关的需求创建了不同的线程池
- ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法能获得任务执行的状态并且可以获取任务的返回值。
- ThreadPoolExecutor 可以创建自定义线程池
- Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 `get()` 方法获取计算的结果

## 2. 线程池的创建

> 引用《阿里巴巴 Java 开发手册》中关于线程池的内容：
>
> 【强制】线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：`Executors` 返回的线程池对象的弊端如下：
>
> 1. `FixedThreadPool` 和 `SingleThreadPool`：允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM
> 2. `CachedThreadPool`：允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量的线程，从而导致 OOM

### 2.1. Executors

- `Executors`：提供了一系列工厂方法用于创建线程池，例如，使用该类中的静态方法`newFixedThreadPool()`，返回的线程池都实现了 `ExecutorService` 接口。
- `ExecutorService`：代表一个线程池，静态方法`newFixedThreadPool()`的返回值

```java
static ExecutorService newFixedThreadPool(int nThreads)
// 创建一个可重用固定线程数的线程池，方法返回值是ExecutorService对象。
// 参数int nThreads: 线程池中线程的数量

Future<?> submit(Runnable task)
// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。

<T> Future<T> submit(Callable<T> task)
// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。
```

### 2.2. ThreadPoolExecutor

#### 2.2.1. 构造方法

ThreadPoolExecutor 类的构造方法及参数说明

```java
public ThreadPoolExecutor(int corePoolSize, // 核心线程数
                          int maximumPoolSize, // 最大线程池大小，也就是线程池总的大小
                          long keepAliveTime, // 线程最大空闲时间
                          TimeUnit unit, // 时间单位
                          BlockingQueue<Runnable> workQueue, // 线程等待队列
                          ThreadFactory threadFactory, // 线程创建工厂
                          RejectedExecutionHandler handler // 拒绝策略
                        )
```

#### 2.2.2. 创建线程池的核心构造参数

可以通过配置不同的参数，创建出行为不同的线程池，以下是 `ThreadPoolExecutor` 构造函数的重要参数：

- `corePoolSize`：线程池的核心线程数，线程数定义了最小可以同时运行的线程数量
- `maximumPoolSize`：线程池允许存在的最大工作线程数
- `workQueue`：任务执行前保存任务的队列，保存由 execute 方法提交的 `Runnable` 任务。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。

其他常见参数：

- `keepAliveTime`：超过核心线程数时闲置线程的存活时间。即当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime` 配置的时间才会被回收销毁
- `unit`：`keepAliveTime` 参数的时间单位
- `threadFactory`：为线程池提供创建新线程的线程工厂
- `handler`：线程池任务队列超过 `maximumPoolSize` 之后的拒绝策略

#### 2.2.3. ThreadPoolExecutor 饱和(拒绝)策略

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了线程时，ThreadPoolExecutor 定义一些策略：

- `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException` 来拒绝新任务的处理。
- `ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务。不会丢弃任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果应用程序可以承受此延迟并且不能丢弃任何一个任务请求的话，可以选择这个策略。
- `ThreadPoolExecutor.DiscardPolicy`：不处理新任务，直接丢弃掉。
- `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求。

例如：Spring 通过 `ThreadPoolTaskExecutor` 或者直接通过 `ThreadPoolExecutor` 的构造函数创建线程池的时候，当不指定 `RejectedExecutionHandler` 饱和策略的话来配置线程池的时候默认使用的是 `ThreadPoolExecutor.AbortPolicy`。在默认情况下，`ThreadPoolExecutor` 将抛出 `RejectedExecutionException` 来拒绝新来的任务，这代表将丢失对这个任务的处理。对于可伸缩的应用程序，建议使用 `ThreadPoolExecutor.CallerRunsPolicy`。当最大池被填满时，此策略可以提供可伸缩队列。

## 3. 线程池的状态

- `RUNNING`：这是最正常的状态，接受新的任务，处理等待队列中的任务。
- `SHUTDOWN`：不接受新的任务提交，但是会继续处理等待队列中的任务。
- `STOP`：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。
- `TIDYING`：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 `TIDYING` 状态时，会执行钩子方法 `terminated()`。
- `ERMINATED`：`terminated()` 方法结束后，线程池的状态就会变成这个。

## 4. 4种线程池

Java 里面线程池的顶级接口是 `Executor`，但是严格意义上讲 `Executor` 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 `ExecutorService`。

### 4.1. newCachedThreadPool

创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。**调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程**。因此，长时间保持空闲的线程池不会使用任何资源。

### 4.2. newFixedThreadPool

**创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程**。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。

### 4.3. newScheduledThreadPool

创建一个核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。创建一个周期性执行任务的线程池。如果闲置，非核心线程池会在 DEFAULT_KEEPALIVEMILLIS 时间内回收

```java
ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);

scheduledThreadPool.schedule(newRunnable(){
    @Override
    public void run() {
        System.out.println("延迟三秒");
    }
}, 3, TimeUnit.SECONDS);

scheduledThreadPool.scheduleAtFixedRate(newRunnable(){
    @Override
    public void run() {
        System.out.println("延迟 1 秒后每三秒执行一次");
    }
}, 1, 3, TimeUnit.SECONDS);
```

### 4.4. newSingleThreadExecutor

`Executors.newSingleThreadExecutor()`返回一个线程池（这个线程池只有一个线程），**这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去**！此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

## 5. 线程池使用 – Runnable 接口

### 5.1. 线程池使用Runnable的步骤

1. 通过 Executors 工厂类的静态方法来创建线程池对象：`newFixedThreadPool(int size)`

```java
// 创建线程池对象
ExecutorService tp = Executors.newFixedThreadPool(线程数量);
```

2. 定义Runnable的实现类
3. 重写run方法
4. 创建Rannable实现类对象

```java
MyRunnable mr = new MyRunnable();
```

5. 调用`submit(Runnable task)`提交任务，每次调用该方法就使用线程池中的一条线程，线程完毕后再放回线程池。

```java
tp.submit(mr);
//或者使用匿名内部类的方法传入Runnable对象，调用submit方法
tp.submit(new Runnable(){
    @Override
    public void run(){
        //重写run方法
    }
});
```

6. 销毁线程池
    - `shutdown()`：销毁线程池，要等待线程池中的所有任务执行完成后才销毁。
    - `shutdownNow()`：立即销毁线程池，不管线程池中的任务是否执行完成。（一般比较少用）

### 5.2. 线程池的执行任务过程

1. 刚开始创建好线程池，没有任务要执行，线程池的线程会等待任务
2. 往线程池中提交任务，线程池会派线程执行任务，有些线程没有任务接着等待
3. 如果线程池中的任务比线程多，线程池中个的线程执行任务，后面的任务等待，等到线程执行完任务，空闲的时候，就执行后面的任务
4. 如果所有任务都执行完，线程就等待任务，直到线程池被销毁，这些线程也就销毁

## 6. 线程池使用 – Callable 接口

### 6.1. Callable 接口作用

也是放在子线程上面执行的代码，返回结果并且可能抛出异常的任务。

### 6.2. Callable 接口方法

```java
@FunctionalInterface
public interface Callable<V> {
    /* 计算结果，如果无法计算结果，则抛出一个异常。 */
    V call() throws Exception;
}
```

`Callable` 与 `Runnable` 接口的区别：

- `Runnable` 接口的方法是 `run()`
- `Callable` 接口的方法是 `call()`

### 6.3. call方法的特点

1. 可以有返回值
2. 可以抛出异常

### 6.4. Callable使用线程池的步骤

1. 获取线程池

```java
// 使用Executors的静态方法，定义创建的线程池的线程数量
public static ExecutorService newFixedThreadPool(int nThreads);

// 例如：
ExecutorService tp = Executors.newFixedThreadPool(线程数量);
```

2. 定义 Callable 的实现类
3. 重写 call 方法
4. 创建 Callable 实现类对象

```java
MyCallable mc = new MyCallable();
```

5. 往线程池中调用 submit(Callable<T> task) 提交任务

```java
tp.submit(mc);
// 或者使用匿名内部类的方法传入Callable对象，调用submit方法
tp.submit(new Callable(){
    @Override
    public void call(){
        // 重写run方法
    }
});
```

6. 销毁线程池shutdown();

**注意：可以同时往线程池中提交 `Runnable` 和 `Callable` 任务**

### 6.5. 获取call()方法中的返回值Future

1. 获取 Future 对象

```java
Future<Integer> future = pool.submit(mc);
```

2. 根据Fufutre对象调用get()方法拿到Call方法的返回值

```java
Integer i = future.get();
```

**注：如果多个线程调用了Future的get()方法，下面的线程是同步执行的。因为可能返回值会参与其他的操作，如果异步执行的话，那后面的操作就会出现问题，有些值还没有返回，所以系统规定了是同步执行。**

**Code Demo:(获取call方法返回值Future)**

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/*
	使用线程池方式执行任务,返回1-n的和
*/
public class MoonZero {
    public static void main(String[] args) throws Exception {
        // 创建线程池对象
        ExecutorService pool = Executors.newFixedThreadPool(2);
        // 定义变量接收线程的返回值，使用了匿名对象
        Future<Integer> future1 = pool.submit(new MyCallable(100));
        Integer sum1 = future1.get();
        Future<Integer> future2 = pool.submit(new MyCallable(50));
        Integer sum2 = future2.get();

        System.out.println("1-100的和是：" + sum1);
        System.out.println("1-50的和是：" + sum2);
        // 销毁线程池，这个会等待线程池中所有任务执行完成才销毁
        pool.shutdown();
    }
}

class MyCallable implements Callable<Integer> {
    // 定义一个成员变量用接收统计的n值
    private int num;

    // 定义一个有参的构造方法，用来传入需要统计的参数
    public MyCallable(int num) {
        this.num = num;
    }

    // 重写call方法
    @Override
    public Integer call() throws Exception {
        // 定义一个变量统计总和
        int sum = 0;
        for (int i = 1; i <= num; i++) {
            sum += i;
        }
        return sum;
    }
}
```

## 7. 线程池最常用的提交任务的两种方式

### 7.1. execute()

`ExecutorService.execute()` 方法接收一个 Runnable 实例，它用来执行一个任务

```java
public void execute(Runnable runnable);
```

### 7.2. submit()

`ExecutorService.submit()` 方法返回的是 Future 对象。可以用 `isDone()` 来查询 Future 是否已经完成，当任务完成时，它具有一个结果，可以调用 `get()` 来获取结果。也可以不用 `isDone()` 进行检查就直接调用 get()，在这种情况下， get() 将阻塞，直至结果准备就绪。

```java
public Future<?> submit(Runnable task);
public <T> Future<T> submit(Runnable task, T result);
public <T> Future<T> submit(Callable<T> task);
```
