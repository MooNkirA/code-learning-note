# 并发编程 - CAS 原子操作

## 1. CAS 概念

CAS（Compare And Swap）指比较并交换。是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS 操作采用了乐观锁的思想，通过比较和交换保证共享变量赋值时的原子操作，这个原子操作直接由 CPU 保证。

CAS 算法包含 V,E,N 等 3 个参数：

- V 表示要更新的变量（内存中的值）
- E 表示预期的值（旧值）
- N 表示新值

仅在 V 值等于 E 值时，才会将 V 值设为 N；如果 V 值和 E 值不同，则说明已经有其他线程做了更新，当前线程什么都不做。最后 CAS 返回当前 V 的真实值。

## 2. CAS 原理

通过刚才 `AtomicInteger` 的源码可以看到，`Unsafe` 类提供了原子操作。

### 2.1. Unsafe 类介绍

`Unsafe` 类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用 Unsafe 类会使得出错的几率变大，因此 Java 官方并不建议使用的，官方文档也几乎没有。Unsafe 对象不能直接调用，只能通过反射获得。

![](images/231170922239684.png)

### 2.2. Unsafe 实现 CAS

![](images/399230922227551.png)

## 3. CAS 使用场景

CAS 获取共享变量时，为了保证该变量的可见性，需要使用 `volatile` 修饰。结合 CAS 和 `volatile` 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。

因为没有使用 `synchronized`，所以线程不会陷入阻塞，这是效率提升的因素之一。但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。

## 4. CAS 与 volatile

其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。

在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。它可以用来修饰成员变量和静态成员变量，避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。因此 CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果

> Notes: volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）

