# 并发编程03-线程安全与锁

## 1. 线程安全

### 1.1. 多线程程序注意事项

1. **线程之间的安全性**。同一个进程里面的多线程是资源共享的，也就是都可以访问同一个内存地址当中的一个变量。例如：若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的：若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全
2. **线程之间的死锁**。为了解决线程之间的安全性引入了 Java 的锁机制，而一不小心就会产生 Java 线程死锁的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成
3. **线程太多了会将服务器资源耗尽形成死机当机**。线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及 CPU 的“过渡切换”，造成系统的死机

### 1.2. 线程安全概念与解决方法

#### 1.2.1. 概念

- 多个线程同时操作一个共享资源时，仍然能得到正确的结果，则称为线程安全。
- 使用多线程，容易造成数据错乱。
- 可能会出现线程安全问题的因素：
    1. 多个线程
    2. 有共享数据
    3. 有多条语句操作共享数据

**注意**：实际开发中，要先保证单线程能够正确执行。

#### 1.2.2. 线程安全问题分析

一个程序运行多个线程本身是没有问题的，问题出在多个线程的共享资源。

多个线程读共享资源其实也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题。一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为**临界区(Critical Section)**

多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了**竞态条件(Race Condition)**

#### 1.2.3. 解决方案

Java中提供了线程同步机制，它能够解决上述的线程安全问题。线程同步机制的作用：保证只有一个线程进入被同步的代码。解决线程案例的方案如下：

- 阻塞式的解决方案：`synchronized`，`Lock`
- 非阻塞式的解决方案：原子变量

### 1.3. 变量的线程安全分析

#### 1.3.1. 成员变量和静态变量是否线程安全

- 如果成员变量和静态变量都没有共享，则线程安全
- 如果成员变量和静态变量被共享了，根据它们的状态是否能够改变，又分两种情况
    - 如果只有读操作，则线程安全
    - 如果有读写操作，则这段代码是临界区，需要考虑线程安全

#### 1.3.2. 局部变量是否线程安全

- 局部变量是线程安全的
- 局部变量引用的对象可能会出现线程不安全的情况
    - 如果该对象没有逃离方法的作用范围，它是线程安全的
    - 如果该对象逃离方法的作用范围，则可能出现的线程安全

#### 1.3.3. 常见线程安全类

`String`、`Integer`、`StringBuffer`、`Random`、`Vector`、`Hashtable`、`java.util.concurrent` 包下的类。

以上线程安全的类是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。它们的每个方法是原子的，但注意它们**多个方法的组合不是原子**的

##### 1.3.3.1. 线程安全类方法的组合

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
    table.put("key", value);
}
```

以上方法的组合，不同线程可能都判断 `key` 值为空，然后同时调用 `put` 方法就可能出现线程安全问题

##### 1.3.3.2. 不可变类线程安全性

String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。

### 1.4. 死锁

#### 1.4.1. 概述

死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞（相互等待）的现象，若无外力作用，它们都将无法推进下去。这是同步锁使用的弊端。

此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。

```java
Object A = new Object();
Object B = new Object();
Thread t1 = new Thread(() -> {
    synchronized (A) {
        LOGGER.debug("t1 get lock A");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (B) {
            LOGGER.debug("t1 get lock B");
            LOGGER.debug("t1 operate....");
        }
    }
}, "t1");

Thread t2 = new Thread(() -> {
    synchronized (B) {
        LOGGER.debug("t2 get lock B");
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (A) {
            LOGGER.debug("t2 get lock A");
            LOGGER.debug("t2 operate...");
        }
    }
}, "t2");

t1.start();
t2.start();
```

上面示例中，线程1通过 `synchronized (A)` 获得 A 锁，然后通过 `Thread.sleep(1000);` 让线程2休眠 1s 为的是让线程2得到CPU执行权，然后线程2获取到B锁。线程1和线程2休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。

#### 1.4.2. 使用同步代码块的弊端

1. 效率低
2. 可能产生死锁

#### 1.4.3. 产生死锁的4个必要条件

- **互斥条件**：线程(进程)对于所分配到的资源具有排它性，即同一个资源同一时间只能被一个线程(进程)访问（占用），直到被该线程(进程)释放
- **请求与保持条件**：一个线程(进程)因请求被占用资源而发生阻塞时，对自已获得的资源保持不放。
- **不可剥夺条件**：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺让该线程释放，只能由线程使用完毕后自行释放资源。
- **循环等待条件**：当发生死锁时，所等待的线程(进程)必定会形成一个环路（多个线程循环请求资源，类似于死循环），造成永久阻塞

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立；反之，如果上述条件之一不满足，就不会发生死锁。

#### 1.4.4. 防止死锁的方法

- 避免死锁要注意加锁顺序
- 尽量使用 ReentrantLock、ReentrantReadWriteLock 的 `tryLock(long timeout, TimeUnit unit)` 的方法，设置超时时间，超时可以退出防止死锁。
- 尽量使用 Java.util.concurrent 并发类代替自定义的锁。
- 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
- 尽量减少同步的代码块。

#### 1.4.5. 定位死锁

- 检测死锁可以使用 jconsole 工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁
- 另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 `top` 先定位到 CPU 占用高的 Java 进程，再利用 `top -Hp` 进程 id 来定位是哪个线程，最后再用 jstack 排查

### 1.5. 活锁

#### 1.5.1. 定义

活锁是指，任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试。活锁有两种情况：

1. 两个线程互相改变对方的结束条件，最终两个线程都无法结束
2. 两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。

#### 1.5.2. 活锁和死锁的区别

- 处于活锁的实体是在不断的改变状态；而处于死锁的实体表现为等待。
- 活锁有可能自行解开，死锁则不能。

#### 1.5.3. 活锁解锁方法

解决方法：每个线程休眠随机数，错开拿锁的时间。

```java
private static volatile int count = 10;

public static void main(String[] args) {
    new Thread(() -> {
        // 期望减到 0 退出循环
        while (count > 0) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            count--;
            System.out.println("count: " + count);
        }
    }, "t1").start();
    new Thread(() -> {
        // 期望超过 20 退出循环
        while (count < 20) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            count++;
            System.out.println("count: " + count);
        }
    }, "t2").start();
}
```

### 1.6. 线程饥饿

线程饥饿是指：一个或者多个线程因为种种原因无法获得所需要的资源，始终得不到 CPU 调度执行，也不能够结束。示例：

```java
for (int i = 0; i < 2; i++) {
    Thread thread = new Thread(() -> {
        while(true){
            System.out.println("高优先级线程执行....");
        }
    });
    thread.setPriority(Thread.MAX_PRIORITY);
    thread.start();
}

Thread.sleep(1000);
Thread me = new Thread(() ->  System.out.println("......................低优先级线程执行了。") );
me.setPriority(Thread.MIN_PRIORITY);
me.start();
```

Java 中导致线程饥饿的原因：

1. 高优先级线程吞噬所有的低优先级线程的获取 CPU 调试的机率。
2. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
3. 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 `wait` 方法)，因为其他线程总是被持续地获得唤醒。

## 2. synchronized 对象锁

### 2.1. 简介

`synchronized` 关键字，俗称的“对象锁”。它采用互斥的方式让同一时刻至多只有一个线程能持有“对象锁”，其它线程再想获取这个“对象锁”时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。`synchronized` 可以修饰类、方法、变量。

> 值得注意，虽然 java 中互斥和同步都可以采用 `synchronized` 关键字来完成，但它们还是有区别的：
>
> - 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
> - 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点

在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。

在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 锁效率做了较大优化。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

### 2.2. synchronized 同步代码块

#### 2.2.1. 同步代码块语法格式

```java
synchronized (锁对象) {
	// 多个线程同时操作的共享资源的代码
}
```

**注意事项**：

- 锁对象可以是任意类型的对象。（可以创建 `Object` 对象）
- 该锁对象必须要被所有的线程共享。将锁对象定义为成员变量，并使用 `static` 修饰。

#### 2.2.2. 同步代码块作用

能够保证同一时间只有一个线程进入同步代码块中执行代码，作用于**调用的对象**。同步代码相当于那段代码是单线程执行，其他线程不能进去操作。

```java
import java.util.ArrayList;
import java.util.Random;

/*
 * 训练案例 3
 * 有一个抽奖池, 该抽奖池中存放了奖励的金额, 该抽奖池用一个数组
 * 	int[] arr = {10,5,20,50,100,200,500,800,2,80,300};
 * 	创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”，
 * 	随机从arr 数组中获取奖项元素并打印在控制台上,格式如下:
 * 抽奖箱1 又产生了一个 10 元大奖
 * 抽奖箱2 又产生了一个 100 元大奖
 */
public class MyThread extends Thread {
    // 创建静态成员变量
    private static int[] arr = { 10, 5, 20, 50, 100, 200, 500, 800, 2, 80, 300 };
    private static Object obj = new Object();
    private static ArrayList<Integer> array = new ArrayList<Integer>();

    public MyThread() {
        super();
    }

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        Random ran = new Random();
        // 创建同步代码块
        while (array.size() < arr.length) {
            synchronized (obj) {
                int index = ran.nextInt(arr.length);
                // 判断元素有没有之前抽过
                if (array.contains(arr[index])) {
                    continue;
                } else {
                    array.add(arr[index]);
                }
                System.out.println(this.getName() + " 又产生了一个 " + arr[index] + " 元大奖。");
            }
        }
    }
}
```

#### 2.2.3. synchronized 面向对象方式的改造

把需要保护的共享变量放入一个类，再使用 `synchronized` 关键字保存，示例如下：

```java
public class SynchronizedClass {
    public static void main(String[] args) throws InterruptedException {
        // 创建包含共享资源的对象，在对象中进行线程安全的控制
        Counter counter = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter.increment();
            }
        }, "t1");

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter.decrement();
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        // 程序如果是线程安全的，最终结果是0
        System.out.println("count: " + counter.get());
    }
}

class Counter {
    private int count = 0;

    public void increment() {
        // synchronized 修饰代码，让代码块内的代码同时只有一个线程能执行
        synchronized (this) {
            count++;
        }
    }

    public void decrement() {
        synchronized (this) {
            count--;
        }
    }

    public int get() {
        synchronized (this) {
            return count;
        }
    }
}
```

### 2.3. synchronized 同步方法

#### 2.3.1. 同步方法语法格式

同步方法的语法格式是：在返回值前面添加 `synchronized` 关键字即可

##### 2.3.1.1. 修饰普通方法

```java
修饰符 synchronized 返回值类型 方法名 ( 参数列表 ) {
	// 多个线程同时操作的共享资源的代码
}
```

相当于

```java
修饰符 返回值类型 方法名 ( 参数列表 ) {
	synchronized (this) {
	    // 多个线程同时操作的共享资源的代码
	}
}
```

> Notes: 非静态同步方法实质也是使用锁对象，默认锁对象是 `this`。因此当一个线程进入某个对象的 `synchronized` 修饰的方法 A 之后，其它线程不可进入此对象的 `synchronized` 修饰的方法 B，因为非静态方法上的 `synchronized` 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

##### 2.3.1.2. 修饰静态方法

```java
修饰符 static synchronized 返回值类型 方法名 ( 参数列表 ) {
	// 多个线程同时操作的共享资源的代码
}
```

相当于

```java
修饰符 static 返回值类型 方法名 ( 参数列表 ) {
	synchronized (当前类.class) {
	    // 多个线程同时操作的共享资源的代码
	}
}
```

> **注意事项**：静态同步方法的锁对象是 `类名.class`。每个类中的class对象都只有一个。无论多少个对象都共享这个class对象。（**加上静态修饰符之后，就默认锁对象是`.class`**）

#### 2.3.2. 同步方法注意问题

**当一个对象被锁住时，对象里面所有用 `synchronized` 修饰的方法都将产生堵塞，而对象里非 `synchronized` 修饰的方法可正常被调用，不受锁影响。**

- `synchronized` 修饰静态方法，作用范围是整个静态方法，作用于**所有对象**
- `synchronized` 修饰类，作用范围是类括号括起来的部分，作用于**所有对象**

如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。

#### 2.3.3. 同步方法示例

能够保证同一时间只有一个线程执行方法中的代码，作用于**调用的对象**

```java
/*
 * 训练案例4
 * 写一个卖票的程序,
 * 1.写一个类,该类继承Thread.有一个私有类型的int 作为参数tickets.
 * 	票的总数为100,完成run 方法,输出结果的格式如下:
 * 	当前窗口为:窗口a,剩余票数为19,其中窗口a 为线程的名字
 * 2.开启四个卖票窗口(开始四个线程),同时执行卖票的程序
 */
public class Tickets extends Thread {
    private static int tickets = 100;

    // 生成有参构造方法
    public Tickets() {
        super();
    }

    public Tickets(String name) {
        super(name);
    }

    @Override
    public void run() {
        while (tickets != 0) {
            saleTicket();
        }
    }

    // 同步方法
    public static synchronized void saleTicket() {
        if (tickets > 0) {
            System.out.println(Thread.currentThread().getName() + "剩余票数为:" + --tickets);
        }
    }
}
```

### 2.4. 多线程中 synchronized 锁升级的原理

synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此锁对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。

锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 `synchronized` 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。

### 2.5. 小结

`synchronized` 关键字修饰 static 静态方法和代码块上都是是给 Class 类上锁。而 `synchronized` 关键字修饰实例方法是给对象实例上锁。

尽量不要使用 `synchronized(String a)` 因为JVM中，字符串常量池具有缓存功能！

## 3. Lock接口（实现线程安全）

### 3.1. Lock 接口的概述

- JDK 1.5 新特性
- 专门用来实现线程安全的技术
- `Lock` 实现提供了比使用 `synchronized` 方法和语句可获得的更广泛的锁定操作
- **`Lock` 和 `synchronized` 都是用来同步代码的，保证线程安全**

### 3.2. Lock 接口的方法

```java
void lock()
```

- 获取锁

```java
void unlock()
```

- 释放锁

**`ReentrantLock` 是互斥锁，`ReentrantLock` 类就是实现了 `Lock` 接口**

### 3.3. Lock 使用步骤与格式

- Lock 使用步骤：
    1. 创建Lock的实现类对象(ReentrantLock)
    2. 调用 ReentrantLock 对象的 lock() 方法，获取锁
    3. 将需要共享的代码块包裹起来
    4. 调用 ReentrantLock 对象的 unlock() 方法，释放锁
- 格式：

```java
// 创建Lock现实类对象(成员变量)
private static Lock l = new ReentrantLock();

// 在run()方法中
l.lock();    // 获取锁
try {
    // 访问共享资源的代码
} finally {
    l.unlock();    // 释放锁, 锁一定要释放
}
```

> Tips:  **必须保证获取锁和释放锁要成对出现。**

### 3.4. Lock 和 synchronized

#### 3.4.1. synchronized 和 ReentrantLock 的区别

**两者的共同点**：

- 都是用来协调多线程对共享对象、变量的访问
- 都是可重入锁，同一线程可以多次获得同一个锁
- 都保证了可见性和互斥性

**两者的不同点**：

- synchronized 是JKD 1.0 就出现的，Lock 接口是 JDK 1.5 后出现。
- Lock 是 Java 的一个接口；而 synchronized 是 Java 的内置关键字，synchronized 是内置的语言实现，属于 JVM 级别。
- synchronized 可以给类、方法、代码块加锁；而 Lock 只能给代码块加锁
- ReentrantLock 显式的获得、释放锁（**即必须手动加锁与释放锁**），synchronized 隐式获得释放锁（**不需要手动释放锁**）
- **synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 `unLock()` 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。**
- ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性
- ReentrantLock 可以实现公平锁
- ReentrantLock 通过 Condition 可以绑定多个条件
- 底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略
- Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。
- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到
- Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。

> Notes: **synchronized 是悲观锁**

#### 3.4.2. synchronized 和 ReentrantLock 的选择

从性能上考虑，如果有很多个线程同时抢夺资源时，`Lock` 接口的效率是要高于 `synchronized`，如果抢夺资源不激烈时，两个性能差不多。

## 4. （！待整理）JAVA 锁分类

### 4.1. 乐观锁

#### 4.1.1. 简介

乐观锁（Optimistic Locking）是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是**在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作**（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，**比较当前值跟传入值是否一样，一样则更新，否则失败**。

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本( Version )记录机制实现。何谓数据版本?即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 "version" 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

#### 4.1.2. 乐观锁示例

如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时(如更改用户帐户余额)，如果采用悲观锁机制，也就意味着整个操作过 程中(从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作 员中途去煮咖啡的时间)，数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果。

乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本 ( Version )记录机制实现。何谓数据版本?即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 "version" 字段来实现。

读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

对于上面修改用户帐户信息的例子而言，假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ;而当前帐户余额字段( balance )为 $100 。

1. 操作员 A 此时将其读出( version=1 )，并从其帐户余额中扣除 $50( $100-$50 )。
2. 在操作员 A 操作的过程中，操作员B 也读入此用户信息( version=1 )，并从其帐户余额中扣除 $20 ( $100-$20 )。
3. 操作员 A 完成了修改工作，将数据版本号加一( version=2 )，连同帐户扣除后余额( balance=$50 )，提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
4. 操作员 B 完成了操作，也将版本号加一( version=2 )试图向数据库提交数据( balance=$80 )，但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 " 提交版本必须大于记录当前版本才能执行更新 " 的乐观锁策略，因此，操作员 B 的提交被驳回。

这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。

### 4.2. 悲观锁

悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。**java中的悲观锁就是Synchronized**，AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 `RetreenLock`。

### 4.3. 自旋锁

自旋锁原理非常简单，**如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。**

线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。

如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。

#### 4.3.1. (待整理)自旋锁的优缺点

## 5. ReentrantLock

### 5.1. 概述

从Java 5开始，引入了一个高级的处理并发的`java.util.concurrent`包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。

`java.util.concurrent.locks` 包提供的 `ReentrantLock` 用于替代 `synchronized` 加锁。相对于 `synchronized`，它具备如下特点：

- 可中断
- 可以设置超时时间
- 可以设置为公平锁
- 支持多个条件变量

与 `synchronized` 一样，都支持可重入

### 5.2. 基础语法

```java
ReentrantLock lock = new ReentrantLock()
// 获取锁
reentrantLock.lock();
try {
    // 临界区
} finally {
    // 释放锁
    reentrantLock.unlock();
}
```

`ReentrantLock`获取锁更安全。必须先获取到锁，再进入`try {...}`代码块，最后使用 `finally` 保证释放锁；也可以使用`tryLock()`尝试获取锁。

### 5.3. 可重入锁

可重入，是指同一个线程如果首次获得了锁，那么因为它是这把锁的拥有者，因此有权利多次获取这把锁的使用权。如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住

`synchronized` 关键字<font color=red>**隐式的支持重进入**</font>，比如一个 `synchronized` 修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。

`ReentrantLock` 在调用 `lock()` 方法时，已经获取到锁的线程，能够再次调用`lock()`方法获取锁而不被阻塞。

```java
private final static ReentrantLock reentrantLock = new ReentrantLock();

@Test
public void testReentrant() {
    method1();
}

public void method1() {
    // 第1次获取锁
    reentrantLock.lock();
    try {
        System.out.println("execute method1");
        method2();
    } finally {
        reentrantLock.unlock();
    }
}

public void method2() {
    // 第2次获取锁，可多次获取
    reentrantLock.lock();
    try {
        System.out.println("execute method2");
        method3();
    } finally {
        reentrantLock.unlock();
    }
}

public void method3() {
    reentrantLock.lock();
    try {
        System.out.println("execute method3");
    } finally {
        reentrantLock.unlock();
    }
}
```

### 5.4. 等待锁可打断

线程执行的过程中，调用`ReentrantLock`的`lock`等待获取锁，这是不可中断模式，此方式调用该线程的`interrupt`方法，不会打断线程的等待。示例如下：

```java
@Test
public void test1() throws IOException {
    Thread t1 = new Thread(() -> {
        System.out.println("t1线程启动了...");
        // lock 方法，t1 线程进行等待，获取锁。此方式不会被 interrupt 打断
        reentrantLock.lock();
        try {
            System.out.println("t1线程获得了锁...");
        } finally {
            // t1线程释放锁
            reentrantLock.unlock();
        }
    }, "t1");

    reentrantLock.lock();
    System.out.println("主线程获得了锁...");
    t1.start(); // 启动t1线程
    try {
        Thread.sleep(1000);
        t1.interrupt();
        System.out.println("主线程执行 interrupt 打断");
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // 主线程释放锁
        reentrantLock.unlock();
        System.out.println("主线程释放锁");
    }
    System.in.read();
}
```

线程执行的过程中，调用`ReentrantLock`的`lockInterruptibly`等待获取锁，这是可中断模式，此方式调用该线程的`interrupt`方法，会打断线程的等待。示例如下：

```java
@Test
public void test2() throws IOException {
    Thread t1 = new Thread(() -> {
        System.out.println("t1线程启动了..");
        try {
            // lockInterruptibly 方法获取锁，等待过程是可以被打断
            reentrantLock.lockInterruptibly();
        } catch (InterruptedException e) {
            e.printStackTrace();
            System.out.println("t1线程等待锁的过程中被打断...");
            return;
        }
        try {
            System.out.println("t1线程获得了锁...");
        } finally {
            // t1线程释放锁
            reentrantLock.unlock();
        }
    }, "t1");

    reentrantLock.lock();
    System.out.println("主线程获得了锁...");
    t1.start();
    try {
        Thread.sleep(1000);
        t1.interrupt();
        System.out.println("主线程执行 interrupt 打断");
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        reentrantLock.unlock();
        System.out.println("主线程释放锁");
    }
    System.in.read();
}
```

### 5.5. 等待锁可超时

```java
public boolean tryLock()
public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException
```

`ReentrantLock`类的`tryLock()`方法作用是立即尝试获取锁。能成功获取锁则返回`true`，否则返回`false`

```java
@Test
public void test1() throws IOException {
    Thread t1 = new Thread(() -> {
        System.out.println("t1线程启动了...");
        // tryLock 方法立即获取锁对象，成功获取到锁则返回true，否则返回false
        if (!reentrantLock.tryLock()) {
            System.out.println("t1线程获取锁失败，返回...");
            return;
        }
        try {
            System.out.println("t1线程获得了锁...");
        } finally {
            // t1线程释放锁
            reentrantLock.unlock();
        }
    }, "t1");

    reentrantLock.lock();
    System.out.println("主线程获得了锁...");
    t1.start(); // 启动t1线程
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // 主线程释放锁
        reentrantLock.unlock();
        System.out.println("主线程释放锁");
    }
    System.in.read();
}
```

`ReentrantLock`类的`tryLock(long timeout, TimeUnit unit)`方法作用是设置最大等待时间尝试获取锁，如在最大等待时间内可以获取到锁则返回`true`，否则返回`false`

```java
@Test
public void test2() throws IOException {
    Thread t1 = new Thread(() -> {
        System.out.println("t1线程启动了...");
        try {
            // tryLock 方法尝试获取，并可以设置最大等待时间。
            if (!reentrantLock.tryLock(1, TimeUnit.SECONDS)) {
                System.out.println("t1线程等1秒后获取锁失败，返回...");
                return;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try {
            System.out.println("t1线程获得了锁...");
        } finally {
            // t1线程释放锁
            reentrantLock.unlock();
        }
    }, "t1");

    reentrantLock.lock();
    System.out.println("主线程获得了锁...");
    t1.start(); // 启动t1线程
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // 主线程释放锁
        reentrantLock.unlock();
        System.out.println("主线程释放锁");
    }
    System.in.read();
}
```

### 5.6. 公平锁

`ReentrantLock` 提供了一个构造函数，能够控制锁是否是公平的，`ReentrantLock` 默认是不公平的。事实上，公平的锁机制往往没有非公平的效率高。

```java
public ReentrantLock(boolean fair)
```

参数说明：

- `fair`：是否公平锁标识。`true`是公平锁，`false`是非公平锁。

示例：

```java
ReentrantLock lock = new ReentrantLock(true);
lock.lock();
for (int i = 0; i < 500; i++) {
    new Thread(() -> {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " running...");
        } finally {
            lock.unlock();
        }
    }, "t" + i).start();
}
// 1s 之后去争抢锁
Thread.sleep(1000);
new Thread(() -> {
    System.out.println(Thread.currentThread().getName() + " start...");
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + " running...");
    } finally {
        lock.unlock();
    }
}, "强行插入").start();
lock.unlock();
```

> 注意：此测试不一定总能得到相应的结果。公平锁一般没有必要使用，会降低并发度，

### 5.7. 条件变量（整理中）
