## 1. 分布式事务基础理论概述

### 1.1. 什么是事务

什么是事务？举个生活中的例子：你去商店买东西就是一个事务的例子，买东西是一个交易，包含“一手交钱，一手交货”两个动作，交钱和交货这两个动作必须全部成功，交易才算成功，其中任何一个动作失败，交易就必须撤销。

事务的定义：**事务可以看做是一次大的活动，它由不同的小活动组成，这些小活动要么全部成功，要么全部失败。**

### 1.2. 本地事务

在软件系统中，通常由关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。以下回顾数据库事务的四大特性 ACID：

- **A（Atomic）**：原子性，构成事务的所有操作，要么都执行成功，要么全部不执行，不可能出现部分成功部分失败的情况。
- **C（Consistency）**：一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转100元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出100元，李四账户没有增加100元这就出现了数据错误，就没有达到一致性。
- **I（Isolation）**：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务运行过程的中间状态。通过配置事务隔离级别可以避脏读、重复读等问题。
- **D（Durability）**：持久性，事务完成之后，该事务对数据的更改会被持久化到数据库，且不会被回滚。

<u>数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚</u>s

### 1.3. 分布式事务

随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，下图描述了单体应用向分布式微服务应用的演变：

![](images/569313422235947.png)

分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下的事务机制称之为**分布式事务**。

本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑是可以实现事务控制：

```sql
begin transaction；
	-- 1.本地数据库操作：张三减少金额
	-- 2.本地数据库操作：李四增加金额
commit transaction;
```

在分布式环境下，就会变成操作不同数据库，因此以下逻辑是不可能实现事务控制：

```sql
begin transaction；
    -- 1.A微服务操作本地数据库A：张三减少金额
    -- 2.A微服务远程调用B微服务，操作数据库B：让李四增加金额
commit transaction;
```

因此在分布式架构的基础上，传统数据库事务就无法使用了，比如上例，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，怎么实现转账事务？也就是说同样一个功能，原来是由一个系统完成的，即使这个功能包含很多个操作，也可以采用数据库事务(本地事务)搞定，而现在这个功能中包含的多个操作可能是由多个系统(微服务)参与完成的，此时数据库事务(本地事务)就无能为力了，这就需要新的分布式事务理论来支撑了。

## 2. 分布式事务基础理论

分布式事务与本地事务不同的是，分布式系统之所以叫分布式，是因为提供服务的各个节点分布在不同机器上，相互之间通过网络交互，那么必然存在出现网络故障的风险，这个网络断开的专业场景称之为网络分区，但不能因为这点网络问题就导致整个系统无法提供服务，网络因素成为了分布式事务的考量标准之一。因此，分布式事务需要更进一步的理论支持，通过分布式事务的基础理论知识指导来确定分布式事务控制的目标，从而理解每个解决方案。

### 2.1. 分布式事务产生的场景

1. 典型的场景就是微服务架构，微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。 总结：**跨JVM进程产生分布式事务**。

![](images/456071323231701.png)

2. 单体系统访问多个数据库实例 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。 比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。 总结：**跨数据库实例产生分布式事务**。

![](images/513091323249581.png)

3. 多服务访问同一个数据库实例 比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。

![](images/139681423247185.png)

### 2.2. 分布式事务幂等性

#### 2.2.1. 幂等性定义

幂等性指的是：一个业务操作，不管重复执行多少次调用方法或者接口，不会改变业务状态，保证最终产生的效果或返回的结果都和执行一次的结果一致。

#### 2.2.2. 使用幂等性场景

- 用户重复点击(网络波动)
- MQ 消息重复
- 应用使用失败或超时重试机制

#### 2.2.3. HTTP 接口的幂等性

以基于 RESTful API 的角度对部分常见类型请求的幂等性特点进行分析

- GET 请求：查询操作，天然幂等
- POST 请求：新增操作，请求一次与请求多次造成的结果不同，非幂等
- PUT 请求：更新操作，如果是以绝对值更新，则是幂等的；如果是通过增量的方式更新，则非幂等。如下：

```sql
-- 幂等
update t_item set money = 500 where id = 1;
-- 非幂等
update t_item set money = money + 500 where id = 1;
```

- DELETE 请求：删除操作，根据唯一值删除，是幂等的

#### 2.2.4. 实现幂等性的方案

1. 通过数据库唯一索引来实现幂等性，此方案适用于**新增操作**
2. 通过 token + redis 实现幂等性，此方案适用于**新增、修改操作**。实现流程如下：

![](images/327955916249298.jpg)

3. 通过分布式锁实现幂等性，此方案适用于**新增、修改操作**。

```java
public void saveOrder(Item item) throws InterruptedException {
	// 获取锁（重入锁），执行锁的名称
	RLock lock = redissonClient.getLock("lock");
	// 尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位
	boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
	try {
		// 判断是否获取成功
		if (!isLock) {
			log.info("下单操作获取锁失败,order:{}", item);
			throw new RuntimeException("新增或修改失败");
		}
		// 下单操作
	} finally {
		// 释放锁
		lock.unlock();
	}
}
```

### 2.3. 分布式事务解决方案种类

以分布式事务的理论为基础，针对不同的分布式场景业界常见的解决方案有：2PC、TCC、可靠消息最终一致性、最大努力通知这几种。

## 3. 分布式事务解决方案之 2PC (两阶段提交)

TODO: 待整理！

## 4. 分布式事务解决方案之 TCC (补偿事务)

### 4.1. TCC 事务概述

TCC(Try/Confirm/Cancel 三个词语的缩写) 编程模式的核心思想是：针对每个分支事务操作，都要向全局事务管理器（TM）发起方注册 Try（预处理）、Confirm（确认）和 Cancel（撤销）三个操作，具体这些操作由开发者根据业务进行实现，然后分为两个阶段去执行：

- TM 首先发起所有的分支事务的 Try 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Confirm 操作。其中 Confirm 操作若执行失败，TM会进行重试。

![](images/535792711231702.png)

- 若 TM 发起的任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作。其中 Cancel 操作若执行失败，TM会进行重试。

![](images/146422911249582.png)

### 4.2. TCC 中涉及的元素

TCC 分为三个阶段：

1. **Try** 阶段主要是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的 Confirm 一起才能真正构成一个完整的业务逻辑。
2. **Confirm** 阶段主要是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用 TCC 则认为 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。若 Confirm 阶段真的出错了，需引入重试机制或人工处理。
3. **Cancel** 阶段主要是在业务执行错误，需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。

![](images/149391911235948.jpg)

- **TM（事务管理器）**

可以实现为独立的服务，也可以让全局事务发起方充当 TM 的角色，TM 独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。

TM 在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于 Confirm  和 Cancel 失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。

### 4.3. TCC 案例说明

案例1： A转账30元给B，A账户和B账户在不同银行(服务)，当前余额都为100元

![](images/525970615246724.png)

上述案例需要把之前实现的转账的代码拆分成三块，套到 try-confirm-cancel 中，由事务管理器(协调管理)推进AB两个 try 分别执行，在这个过程中，事务管理器会对AB进行监控，一旦任何一方出现了问题，就推进对方执行cancel；如果双方都没有异常，就推进AB执行 Confirm。如果在执行 confirm 或 cancel 过程中出现问题，就引入重试机制或由人工处理。

TCC 解决方案要求每个分支事务实现三个操作 Try/Confirm/Cancel。Try 操作做业务检查及资源预留，Confirm 操作做业务确认操作，Cancel 操作需要实现一个与try相反的操作。TM(事务管理器)首先发起所有的分支事务的 Try 操作，任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Confirm 操作，其中 Confirm/Cancel 操作若执行失败，TM 会进行重试，因此需要实现幂等。Try/Confirm/Cancel 这三个操作的具体实现，由开发者根据业务情况灵活掌握。

TCC不足之处：

- 对应用的侵入性强。业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作，应用侵入性较强，改造成本高。
- 实现难度较大。需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm 和 cancel 接口必须实现幂等。

### 4.4. TCC 解决方案

目前市面上的 TCC 框架众多比如下面这几种：（以下统计时间截止于 2019年07月11日）

|     框架名称     |                    Gitbub地址                    |
| --------------- | ----------------------------------------------- |
| tcc-transaction | https://github.com/changmingxie/tcc-transaction |
| Hmily           | https://github.com/yu199195/hmily               |
| ByteTCC         | https://github.com/liuyangming/ByteTCC          |
| EasyTransaction | https://github.com/QNJR-GROUP/EasyTransaction   |

- Hmily 框架的使用详见[《Hmily-TCC分布式事务解决方案》笔记](/分布式微服务/分布式事务控制解决方案/Hmily-TCC分布式事务解决方案)

### 4.5. TCC 需要注意三种异常处理

TCC 需要注意三种异常处理分别是**空回滚**、**幂等**、**悬挂**

#### 4.5.1. 空回滚

在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。

出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行 Try 阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的 Cancel 方法，从而形成空回滚。

解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。TM 在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张分支事务记录表，其中有全局事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。

#### 4.5.2. 幂等

为了保证 TCC 二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段 Try、Confirm 和 Cancel 接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。

解决思路在上述“分支事务记录”中增加执行状态，每次执行前都查询该状态。

#### 4.5.3. 悬挂

悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。

出现原因是在 RPC 调用分支事务 Try 时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，TM 就会通知 RM 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行，而一个 Try 方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，就称这种情况为悬挂，即业务资源预留后没法继续处理。

解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，“分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行 Try

### 4.6. 总结

如果拿 TCC 事务的处理流程与 2PC 两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能。

而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。

## 5. 分布式事务解决方案之可靠消息最终一致性

### 5.1. 可靠消息最终一致性事务概述

可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。此方案是利用消息中间件完成，如下图：

![](images/10643412239489.png)

### 5.2. 可靠消息最终一致性方案需解决的问题

事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事务问题。因此可靠消息最终一致性方案要解决以下几个问题：

#### 5.2.1. 本地事务与消息发送的原子性

本地事务与消息发送的原子性问题即：事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。

- 如先发送消息，再操作数据库。这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败。

```java
begin transaction;
    //1.发送MQ
    //2.数据库操作
commit transation;
```

- 如先进行数据库操作，再发送消息。此时如果发送MQ消息失败，就会抛出异常，导致数据库事务回滚；但如果是超时异常，数据库回滚，但MQ其实已经正常发送了，同样会导致不一致。

```java
begin transaction;
    //1.数据库操作
    //2.发送MQ
commit transation;
```

#### 5.2.2. 事务参与方接收消息的可靠性

事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。

#### 5.2.3. 消息重复消费

由于网络的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。

要解决消息重复消费的问题就要事务参与方的方法实现幂等性。

### 5.3. 解决方案

#### 5.3.1. 本地消息表方案

本地消息表这个方案最初是 eBay 提出的，此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。

下面以注册送积分为例来说明，示例中共有两个微服务交互，用户服务和积分服务，用户服务负责添加用户，积分服务负责增加积分。

![](images/286804712236044.png)

交互流程如下：

1. **用户注册**

用户服务在本地事务新增用户和增加 ”积分消息日志“。（用户表和消息表通过本地事务保证一致）。以下是伪代码：

```java
begin transaction;
    //1.新增用户
    //2.存储积分消息日志
commit transation;
```

这种情况下，本地数据库操作与存储积分消息日志处于同一个事务中，本地数据库操作与记录消息日志操作具备原子性。

2. **定时任务扫描日志**

如何保证将消息发送给消息队列？

经过第一步消息已经写到消息日志表中，可以启动独立的线程，定时对消息日志表中的消息进行扫描并发送至消息中间件，在消息中间件反馈发送成功后删除该消息日志，否则等待定时任务下一周期重试。

3. **消费消息**

如何保证消费者一定能消费到消息？

这里可以使用 MQ 的 ack（即消息确认）机制，消费者监听 MQ，如果消费者接收到消息并且业务处理完成后向 MQ 发送 ack（即消息确认），此时说明消费者正常消费消息完成，MQ 将不再向消费者推送消息，否则消费者会不断重试向消费者来发送消息。

积分服务接收到“增加积分”消息，开始增加积分，积分增加成功后向消息中间件回应ack，否则消息中间件将重复投递此消息。由于消息会重复投递，积分服务的“增加积分”功能需要实现幂等性。

#### 5.3.2. RocketMQ 事务消息方案

此内容详见[《RocketMQ - 可靠消息最终一致性事务解决方案》](/分布式微服务/分布式事务控制解决方案/RocketMQ-可靠消息最终一致性事务解决方案)
