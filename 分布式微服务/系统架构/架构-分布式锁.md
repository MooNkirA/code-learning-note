## 1. 分布式锁的概述

### 1.1. 各类型的锁

- 线程锁：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一 JVM 中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如 synchronized是 共享对象头，显示锁 Lock 是共享某个变量（state）。
- 进程锁：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过 synchronized 等线程锁实现进程锁。
- 分布式锁：当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问。

### 1.2. 分布式锁的设计原则

Redis 的官网上对使用分布式锁提出至少需要满足如下三个要求：

1. **互斥（属于安全性）**：在任何给定时刻，只有一个客户端可以持有锁。
2. **无死锁（属于有效性）**：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。
3. **容错性（属于有效性）**：只要大多数 Redis 节点都启动，客户端就可以获取和释放锁。

在分布式锁的设计中还需要考虑：

1. **加锁解锁的同源性**：A 加的锁，不能被 B 解锁。
2. **获取锁是非阻塞的**：如果获取不到锁，不能无限期等待。
3. **高性能**：加锁解锁是高性能的。

> 参考 Redis 官网的[『Distributed Locks with Redis』](https://redis.io/docs/manual/patterns/distributed-locks/) 文章

### 1.3. 分布式锁的常见实现方案

- 基于数据库实现分布式锁：
    - 基于数据库表（锁表，很少使用）
    - 乐观锁（基于版本号）
    - 悲观锁（基于排它锁）
- 基于 redis 实现分布式锁：
    - 单个 Redis 实例：`setnx(key, 当前时间+过期时间)` + Lua
    - Redis 集群模式：Redlock
- 基于 zookeeper 实现分布式锁
    - 临时有序节点来实现的分布式锁，例如：Curator
- 基于 Consul 实现分布式锁

## 2. 基于数据库实现分布式锁

### 2.1. 基于表锁（很少使用）

最简单的方式可能就是直接创建一张锁表，利用数据库的表锁来实现分布式锁。例如：

```sql
CREATE TABLE database_lock (
	`id` BIGINT NOT NULL AUTO_INCREMENT,
	`resource` INT NOT NULL COMMENT '锁定的资源',
	`description` VARCHAR ( 1024 ) NOT NULL DEFAULT "" COMMENT '描述',
	PRIMARY KEY ( id ),
	UNIQUE KEY uiq_idx_resource ( resource ) 
) ENGINE = INNODB DEFAULT CHARSET = utf8mb4 COMMENT = '数据库分布式锁表';
```

当想要获得锁时，可以插入一条数据：

```sql
INSERT INTO database_lock ( resource, description ) VALUES ( 1, 'lock' );
```

当需要释放锁的时，可以删除这条数据：

```sql
DELETE FROM database_lock WHERE resource = 1;
```

### 2.2. 基于悲观锁

#### 2.2.1. 悲观锁实现思路

1. 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
2. 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。（具体响应方式由开发者根据实际需要决定。）
3. 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
4. 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。






