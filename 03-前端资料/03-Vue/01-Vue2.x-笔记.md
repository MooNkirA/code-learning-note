# Vue2.x 基础笔记

Vue 官网：https://cn.vuejs.org/

> 以下是vue的学习笔记，大部分内容引用官网

## 1. vue 简介

### 1.1. 前端开发趋势

- 架构从传统后台MVC向 REST API + 前端`MV*` 迁移
- MV*包括：MVC、MVP、MVVM（如：Angular.js/react.js/Vue.js）

### 1.2. MVVM框架

- 针对具有复杂交互逻辑的前端应用
- 提供基础的架构抽象
- 通过Ajax数据持久化，保存前端用户体验

### 1.3. Vue.js 是什么

Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的<font color=red>**渐进式框架**</font>。

![](images/20211114170151123_978.jpg)

核心思想：**数据驱动 + 组件化的前端开发**。Vue.js最轻量。借鉴了angular的指令和react的组件化

### 1.4. vue 的特性

vue 框架的特性，主要体现在如下两方面：

- <font color=red>**数据驱动视图**</font>
- <font color=red>**双向数据绑定**</font>

#### 1.4.1. 数据驱动视图

在使用了 vue 的页面中，vue 会<font color=red>**监听数据的变化**</font>，从而<font color=red>**自动重新渲染**</font>页面的结构。示意图如下：

![](images/20211114170633632_21730.png)

数据驱动视图的优点是：当页面数据发生变化时，页面会自动重新渲染！

值得注意是：<font color=red>**数据驱动视图是单向的数据绑定**</font>。

#### 1.4.2. 双向数据绑定

在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中。示意图如下：

![](images/20211114171516343_10491.jpg)

双向数据绑定的优点：开发者不再需要手动操作 DOM 元素，来获取表单元素最新的值！

#### 1.4.3. 组件化

作用：扩展HTML元素，封装可重用的代码

**组件设计原则**

- 页面上每个独立的可视/可交互区域视为一个组件
- 每个组件对应一个工程目录，组件所需要的各种资料在此目录下就近维护
- 页面是组件的容器，组件可以嵌套自由组合形成完整的页面

### 1.5. Vue 底层原理

#### 1.5.1. MVVM 概念

MVVM 是 vue 实现**数据驱动视图**和**双向数据绑定**的核心原理。MVVM 指的是 Model、View 和 ViewModel，它把每个 HTML 页面都拆分成了这三个部分，如图所示：

![](images/20211114171948042_22244.png)

- `Model`：表示当前页面渲染时所依赖的数据源。
- `View`：表示当前页面所渲染的 DOM 结构。
- `ViewModel`：表示 vue 的实例，它是 MVVM 的核心。

#### 1.5.2. MVVM 的工作原理

<font color=red>ViewModel 作为 MVVM 的核心</font>，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。

![](images/20211114172150685_15403.png)

- 当**数据源发生变化**时，会被 ViewModel 监听到，ViewModel 会根据最新的数据源**自动更新**页面的结构
- 当**表单元素的值发生变化**时，也会被 ViewModel 监听到，ViewModel 会把变化过后最新的值**自动同步**到 Model 数据源中

### 1.6. vue 版本介绍

当前（2021年），vue 共有 3 个大版本，其中：

- 2.x 版本 是目前企业级项目开发中的**主流版本**
- 3.x 版本 于 2020-09-19 发布，生态还不完善，尚未在企业级项目开发中普及和推广
- ~~1.x 版本~~ 几乎被淘汰，不再建议学习与使用

总结：

- 3.x 版本的 vue 是未来企业级项目开发的趋势
- 2.x 版本的 vue 在未来（1 ~ 2年内）会被逐渐淘汰

### 1.7. Vue 基本使用步骤

1. 导入 vue.js 的 script 脚本文件
2. 在页面中声明一个将要被 vue 所控制的 DOM 区域
3. 创建 vm 实例对象（vue 实例对象）

```html
<!-- 1. 导入 Vue 的库文件，在 window 全局就有了 Vue 这个构造函数 -->
<script src="./lib/vue-2.6.12.js"></script>
<!-- 2. 创建 Vue 的实例对象 -->
<script>
    window.onload = function () {
        // 创建 Vue 的实例对象，即 ViewModel
        const vm = new Vue({
            // el 属性是固定的写法，表示当前 vm 实例要控制页面上的哪个区域，接收的值是一个选择器，即View 视图区域
            el: '#app',
            // data 指向的对象就是要渲染到页面上的数据，即 Model 数据源
            data: {
                username: 'MooNkirA',
            },
        });
    };
</script>

<body>
    <!-- 在页面中声明一个被 vue 所控制的 DOM 区域。
        其中id的值为创建vue实例对象时的 el 属性挂载点，
        由此 DOM 元素就由 vue 控制，可将数据源填充到此 DOM 元素中 -->
    <div id="app">{{ username }}</div>
</body>
```

## 2. Vue 实例

### 2.1. 创建一个 Vue 实例

每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：

```js
var vm = new Vue({
  // 选项
})
```

> 注：经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。

当创建一个 Vue 实例时，可以传入一个**选项对象**。一个 Vue 应用由一个通过 `new Vue` 创建的**根 Vue 实例**，以及可选的嵌套的、可复用的组件树组成。

### 2.2. 数据与方法

- 当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。当这些数据改变时，视图会进行重渲染。
- <font color=red>**值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的**</font>。如果创建实例后再添加一个新的 property，那么此 property 改变将不会触发任何视图的更新。
- 除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。

示例：

```js
// 定义 data 数据对象
const data = { a: 1 };

// 创建 Vue 的实例对象，即 ViewModel。可以传入一个选项对象
const vm = new Vue({
    // el 属性提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标
    el: '#app',
    // data 对象中的所有的 property 将加入到 Vue 的响应式系统中
    data: data,
});

// 获得这个实例上的 property
// 返回源数据中对应的字段
console.log('vm.a == data.a => ', vm.a == data.a); // => true

// 设置 vue 实例中的 property 也会影响到原始数据
vm.a = 2;
console.log('vm.a = 2, data.a => ', data.a); // => 2

// ……反之亦然
data.a = 3;
console.log('data.a = 3, vm.a => ', vm.a);

// 值得注意：只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。
// 如果创建实例后添加一个新的 property，那么此property改变将不会触发任何视图的更新。
vm.b = 2;

// 除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。
console.log('vm.$data === data => ', vm.$data === data); // => true
console.log(
    'vm.$el === document.getElementById("app")  => ',
    vm.$el === document.getElementById('app')
); // => true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
    // 这个回调将在 `vm.a` 改变后调用
    console.log(
        'a newValue is %d, a oldValue is %d',
        newValue,
        oldValue
    );
});
vm.a = 10; // 触发 vue 实例的 watch 方法
```

### 2.3. Vue 实例生命周期钩子

每个 Vue 实例在被创建时都要经过一系列的初始化过程。*如：需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等*。在这个过程中也会运行一些叫做**生命周期钩子的函数**，这给了用户在不同阶段添加自己的代码的机会。常见的生命周期钩子方法有：

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpdate
- updated
- beforeDestroy
- destroyed

以上生命周期钩子函数，在实例生命周期的不同阶段被调用。<font color=red>**生命周期钩子的 `this` 上下文指向调用它的 Vue 实例**</font>。

> **特别注意**：不要在选项对象 property 或回调上使用箭头函数，比如 `created: () => console.log(this.a)` 或 `vm.$watch('a', newValue => this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。

生命周期钩子使用示例。比如 `created` 钩子可以用来在一个实例被创建之后执行代码：

```js
new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` 指向 vm 实例
    console.log('a is: ' + this.a)
  }
})
// => "a is: 1"
```


### 2.4. 生命周期图示

![](images/20211114230051364_6434.png)

<font color=red>**特别值得注意的是：`created`钩子函数和`mounted`钩子函数的区别**</font>

## 3. vue 的指令

指令（Directives）是 vue 为开发者提供的<font color=red>**模板语法**</font>，用于**辅助开发者渲染页面的基本结构**。

vue 中的指令按照不同的用途可以分为如下 6 大类：

1. 内容渲染指令
2. 属性绑定指令
3. 事件绑定指令
4. 双向绑定指令
5. 条件渲染指令
6. 列表渲染指令

> 注意：指令是 vue 开发中最基础、最常用、最简单的知识点

### 3.1. 模板语法

Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。

在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。

实际开发也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。

### 3.2. 内容渲染指令

#### 3.2.1. v-text

`v-text` 作为元素的属性来定义，更新标签体内容。<font color=red>**注意：`v-text` 指令会覆盖元素内默认的值**</font>。

```html
<span v-text="msg"></span>
```

#### 3.2.2. 插值表达式 {{ }}

vue 提供的 `{{ }}` 语法，专门用来解决 `v-text` 会覆盖默认文本内容的问题。这种 `{{ }}` 语法的专业名称是插值表达式（英文名为：Mustache，双大括号），是数据绑定最常见的形式。

Mustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。

```html
<span>Message: {{ msg }}</span>
```

通过使用 `v-once` 指令，能执行一次性地插值，当数据改变时，插值处的内容不会更新。*但请留心这会影响到该节点上的其它数据绑定*

```html
<span>Message: {{ msg }}</span>
```

> 注意：相对于 v-text 指令来说，插值表达式在开发中更常用一些！因为它不会覆盖元素中默认的文本内容。

#### 3.2.3. v-html

`v-text` 指令和插值表达式只能渲染纯文本内容。如果要把包含 HTML 标签的字符串渲染为页面的 HTML 元素，则需要用到 `v-html` 这个指令：

```html
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

![](images/20211115094929206_10077.png)

这个 `span` 的内容将会被替换成为 property 值 `rawHtml`，直接作为 HTML——会忽略解析 property 值中的数据绑定。

#### 3.2.4. 内容渲染指令示例

```html
<script>
    window.onload = function () {
        const vm = new Vue({
            el: '#app',
            data: {
                username: 'MooNkirA',
                gender: '女',
                info: '<h4 style="color: red; font-weight: bold;">我是用样式的标签字符串</h4>',
                msg: '我是初始值',
            },
        });

        // 改变 msg 属性值，测试 v-once 的一次性地插值效果
        vm.msg = '我已经变了！！';
    };
</script>

<body>
    <div id="app">
        <!-- v-text 更新元素的标签内容 -->
        <p v-text="username"></p>
        <!-- 注意：v-text 更新的内容会将标签体内容全部覆盖 -->
        <p v-text="gender">性别：</p>

        <hr />

        <!-- 文本插值 {{  }}。双大括号会将数据解释为普通文本，而非 HTML 代码。 -->
        <p>姓名：{{ username }}</p>
        <p>性别：{{ gender }}</p>
        <!-- 通过使用 v-once 指令，能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： -->
        <span v-once>这个将不会改变: {{ msg }}</span>

        <hr />

        <div v-text="info"></div>
        <div>{{ info }}</div>
        <!-- v-html 将标签体内容直接作为 HTML —— 会忽略解析 property 值中的数据绑定。 -->
        <div v-html="info"></div>
    </div>
</body>
```

### 3.3. 属性绑定指令

#### 3.3.1. v-bind

如果需要为元素的属性动态绑定属性值，则需要用到 `v-bind` 属性绑定指令。用法示例如下：

```html
<div v-bind:id="dynamicId"></div>
```

对于布尔类型的属性(它们只要存在就意味着值为 `true`)，`v-bind` 处理有所不同，如下例：

```html
<button v-bind:disabled="isButtonDisabled">Button</button>
```

上例如果 `isButtonDisabled` 的值是 `null`、`undefined` 或 `false`，则 `disabled` 属性甚至不会被包含在渲染出来的 `<button>` 元素中。

由于 `v-bind` 指令在开发中使用频率非常高，因此，vue 官方提供了属性绑定指令的简写形式（简写为英文的 `:` ）。

```htmL
<!-- 缩写 -->
<img :src="imageSrc">
```

#### 3.3.2. 使用 Javascript 表达式

在 vue 提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算，例如：

```html
<div>{{ number + 1 }}</div>
<div>{{ ok ? 'YES' : 'NO' }}</div>
<div>{{ message.split('').reverse().join('') }}</div>
<div v-bind:id="'list-' + id"></div>
```

表达式有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效：

```html
<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}
<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

#### 3.3.3. 属性绑定指令示例

```html
<script>
    window.onload = function () {
        const vm = new Vue({
            el: '#app',
            data: {
                tips: '请输入用户名',
                photo: 'https://cn.vuejs.org/images/logo.svg',
                index: 3,
            },
        });
    };
</script>

<body>
    <div id="app">
        <!-- v-bind 属性绑定 -->
        <input type="text" v-bind:placeholder="tips" />
        <hr />
        <!-- vue 规定 v-bind: 指令可以简写为 : -->
        <img :src="photo" alt="" style="width: 150px" />

        <hr />

        <!-- 使用 JavaScript 表达式。其限制就是，每个绑定都只能包含单个表达式 -->
        <div>1 + 2 的结果是：{{ 1 + 2 }}</div>
        <div>
            {{ tips }} 反转的结果是：{{ tips.split('').reverse().join('') }}
        </div>
        <!-- 表达式后结果是 box3 -->
        <div :title="'box' + index">这是一个 div</div>

        <!-- 这是语句，不是表达式 -->
        <!-- <div>不会生效的 JavaScript 表达式：{{ var a = 1 }}</div> -->
        <!-- 流控制也不会生效，请使用三元表达式 -->
        <!-- <div>
            不会生效的 JavaScript 表达式：{{ if (ok) { return msg } }}
        </div> -->
    </div>
</body>
```

### 3.4. 事件绑定指令

#### 3.4.1. v-on 监听事件

vue 提供了 `v-on` 事件绑定指令，用来为 DOM 元素绑定事件监听器，并在触发时运行一些 JavaScript 代码。语法格式如下：

```html
<div id="example-1">
  <button v-on:click="counter += 1">Add 1</button>
  <p>The button above has been clicked {{ counter }} times.</p>
</div>

<script>
  var example1 = new Vue({
    el: '#example-1',
    data: {
      counter: 0
    }
  })
</script>
```

> 注意：原生 DOM 对象有 `onclick`、`oninput`、`onkeyup` 等原生事件，替换为 vue 的事件绑定形式后，分别为：`v-on:click`、`v-on:input`、`v-on:keyup`

#### 3.4.2. 事件绑定的简写形式

由于 `v-on` 指令在开发中使用频率非常高，因此，vue 官方为其提供了简写形式（简写为英文的 `@` ）。

```html
<!-- 缩写 -->
<button @click="doThis"></button>
```

#### 3.4.3. 事件处理方法

如果事件处理逻辑会更为复杂，会将处理逻辑封装成函数方法。因此 `v-on` 还可以接收一个需要调用的方法名称。而 `v-on` 绑定的事件处理函数，需要在 `methods` 节点中进行声明。

在原生的 DOM 事件绑定中，可以在事件处理函数的形参处，接收事件参数对象 event。同理，在 v-on 指令（简写为 @ ）所绑定的事件处理函数中，同样可以接收到事件参数对象 event

```html
<div id="example-2">
  <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>
</div>

<script>
    var example2 = new Vue({
      el: '#example-2',
      data: {
        name: 'Vue.js'
      },
      // 在 `methods` 对象中定义方法
      methods: {
        greet: function (event) {
          // `this` 在方法里指向当前 Vue 实例
          alert('Hello ' + this.name + '!')
          // `event` 是原生 DOM 事件
          if (event) {
            alert(event.target.tagName)
          }
        }
      }
    })

    // 也可以用 JavaScript 直接调用方法
    example2.greet() // => 'Hello Vue.js!'
</script>
```

#### 3.4.4. 内联处理器中的方法

除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法，即可以使用 `()` 给方法进行传参：

```html
<div id="example-3">
  <button v-on:click="say('hi')">Say hi</button>
  <button v-on:click="say('what')">Say what</button>
</div>

<script>
    new Vue({
      el: '#example-3',
      methods: {
        say: function (message) {
          alert(message)
        }
      }
    })
</script>
```

如需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```html
<button v-on:click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>

<script>
    // ...
    methods: {
      warn: function (message, event) {
        // 现在我们可以访问原生事件对象
        if (event) {
          event.preventDefault()
        }
        alert(message)
      }
    }
</script>
```

`$event` 是 vue 提供的特殊变量，用来表示原生的事件参数对象 `event`。`$event` 可以解决事件参数对象 `event` 被覆盖的问题。

#### 3.4.5. 事件修饰符

在事件处理函数中调用` event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。因此，vue 提供了事件修饰符的概念，更方便的对事件的触发进行控制。从而方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。常用的 5 个事件修饰符如下：

| 事件修饰符  |                          说明                           |
| :--------: | ------------------------------------------------------- |
| `.prevent` | 阻止默认行为（例如：阻止 `<a>` 连接的跳转、阻止表单的提交等） |
|  `.stop`   | 阻止事件冒泡                                             |
| `.capture` | 以捕获模式触发当前的事件处理函数                            |
|  `.once`   | 绑定的事件只触发1次                                       |
|  `.self`   | 只有在 `event.target` 是当前元素自身时触发事件处理函数      |

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 2.1.4 新增 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>

<!-- 2.3.0 新增 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

> 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `@click.prevent.self` 会阻止所有的点击，而 `@click.self.prevent` 只会阻止对元素自身的点击。
>
> 这个 `.passive` 修饰符尤其能够提升移动端的性能。不要把 `.passive` 和 `.prevent` 一起使用，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，`.passive` 会告诉浏览器你不想阻止事件的默认行为。

#### 3.4.6. 按键修饰符

在监听键盘事件时，经常需要判断详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符，例如：

```html
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

也可以直接将 `KeyboardEvent.key` 暴露的任意有效按键名转换为 `kebab-case` 来作为修饰符。

```html
<!-- 处理函数只会在 $event.key 等于 PageDown 时被调用。 -->
<input v-on:keyup.page-down="onPageDown">
```

#### 3.4.7. 事件绑定指令示例

```html
<script>
    window.onload = function () {
        const vm = new Vue({
            el: '#app',
            data: {
                count: 0,
            },
            methods: {
                add(n) {
                    // 在 methods 处理函数中，this 就是 new 出来的 vm 实例对象
                    console.log(vm === this);
                    console.log(vm);
                    this.count += n;
                },
                sub() {
                    // console.log('触发了 sub 处理函数')
                    this.count -= 1;
                },
                addEvent(e) {
                    this.count += 2;
                    console.log(e);

                    // 判断 this.count 的值是否为偶数
                    if (this.count % 2 === 0) {
                        // 偶数
                        e.target.style.backgroundColor = 'red';
                    } else {
                        // 奇数
                        e.target.style.backgroundColor = '';
                    }
                },
                addEvent1(e, n) {
                    this.count += n;
                    console.log(e);

                    // 判断 this.count 的值是否为偶数
                    if (this.count % 2 === 0) {
                        // 偶数
                        e.target.style.backgroundColor = 'pink';
                    } else {
                        // 奇数
                        e.target.style.backgroundColor = '';
                    }
                },
                show() {
                    console.log('点击了 a 链接');
                },
                btnHandler() {
                    console.log('btnHandler');
                },
                divHandler() {
                    console.log('divHandler');
                },
                clearInput(e) {
                    console.log('触发了 clearInput 方法');
                    e.target.value = '';
                },
                commitAjax(e) {
                    console.log('触发了 commitAjax 方法');
                    console.log('发送数据：' + e.target.value);
                },
            },
        });
    };
</script>

<body>
    <div id="app">
        <p>count 的值是：{{ count }}</p>
        <!-- 直接触发 JavaScript 代码 -->
        <button v-on:click="count += 10">JavaScript 代码 +10</button>
        <!-- 在绑定事件处理函数的时候，可以使用 () 传递参数 -->
        <button v-on:click="add(1)">函数传参 +1</button>
        <!-- v-on: 指令可以被简写为 @ -->
        <button @click="sub">指令简写 -1</button>

        <!-- 原生的 DOM 事件绑定接收事件参数对象 event -->
        <button @click="addEvent">获取原生 DOM 事件对象 +2</button>
        <!-- vue 提供了内置变量，名字叫做 $event，它就是原生 DOM 的事件对象 event -->
        <button @click="addEvent1($event, 3)">
            获取 vue 内置 $event 事件对象 +3
        </button>

        <hr />

        <!-- 事件修饰符 .prevent - 调用 event.preventDefault() -->
        <a href="#" @click.prevent="show">跳转</a>

        <hr />

        <div
            style="
                height: 150px;
                background-color: orange;
                padding-left: 100px;
                line-height: 150px;
            "
            @click="divHandler"
        >
            <!-- 事件修饰符 .stop - 调用 event.stopPropagation() -->
            <button @click.stop="btnHandler">按钮</button>
        </div>

        <hr />

        <!-- 指定事件按键修饰符 -->
        <input
            type="text"
            @keyup.esc="clearInput"
            @keyup.enter="commitAjax"
        />
    </div>
</body>
```

### 3.5. 双向绑定指令

vue 提供了 `v-model` 指令，在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。在不操作 DOM 的前提下，快速获取表单的数据。它会根据控件类型自动选取正确的方法来更新元素。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。

#### 3.5.1. v-model 基础使用

`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

- `text` 和 `textarea` 元素使用 `value` property 和 `input` 事件
- `checkbox` 和 `radio` 使用 `checked` property 和 `change` 事件
- `select` 字段将 `value` 作为 `prop` 并将 `change` 作为事件

##### 3.5.1.1. 文本

```html
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

##### 3.5.1.2. 文本

```html
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

> 在文本区域插值 (`<textarea>{{text}}</textarea>`) 并不会生效，应用 `v-model` 来代替。

##### 3.5.1.3. 复选框

单个复选框，绑定到布尔值：

```html
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
```

多个复选框，绑定到同一个数组：

```html
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
<label for="mike">Mike</label>
<br>
<span>Checked names: {{ checkedNames }}</span>

<script>
    new Vue({
        el: '...',
        data: {
            checkedNames: []
        }
    })
</script>
```

##### 3.5.1.4. 单选按钮

```html
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>

<script>
    new Vue({
        el: 'example-4',
        data: {
            picked: ''
        }
    })
</script>
```

##### 3.5.1.5. 选择框

单选

```html
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>

<script>
    new Vue({
        el: '...',
        data: {
            selected: ''
        }
    })
</script>
```

> 如果 `v-model` 表达式的初始值未能匹配任何选项，`<select>` 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 `change` 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。

多选时 (绑定到一个数组)：

```html
<div id="example-6">
  <select v-model="selected" multiple style="width: 50px;">
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <br>
  <span>Selected: {{ selected }}</span>
</div>
<script>
    new Vue({
        el: '...',
        data: {
            selected: []
        }
    })
</script>
```

#### 3.5.2. v-model 指令的修饰符

为了方便对用户输入的内容进行处理，vue 为 `v-model` 指令提供了 3 个修饰符

##### 3.5.2.1. .lazy

在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步：

```html
<!-- 在“change”时而非“input”时更新 -->
<input v-model.lazy="msg">
```

##### 3.5.2.2. .number

如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：

```html
<input v-model.number="age" type="number">
```

> 注：输入框即使在 `type="number"` 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()` 解析，则会返回原始的值。

##### 3.5.2.3. .trim

如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：

```html
<input v-model.trim="msg">
```

#### 3.5.3. 在组件上使用 v-model（待整理）


### 3.6. 条件渲染指令

条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏。条件渲染指令有如下两个，分别是：

- `v-if`
- `v-show`

#### 3.6.1. v-if

`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 `true` 的时候被渲染。

```html
<h1 v-if="awesome">Vue is awesome!</h1>
```

#### 3.6.2. v-else

可以使用 `v-else` 指令来表示 `v-if` 的另一个分支：

```html
<div v-if="Math.random() > 0.5">
  Now you see me
</div>
<div v-else>
  Now you don't
</div>
```

<font color=red>**注意：`v-else` 指令必须紧跟在带 `v-if` 或者 `v-else-if` 元素的后面使用，否则它将不会被识别！**</font>

#### 3.6.3. v-else-if

2.1.0 版本新增，充当 `v-if` 的“`else-if` 块”，可以连续使用：

```html
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```

<font color=red>**注意：`v-else-if` 指令必须紧跟在带 `v-if` 元素的后面使用，否则它将不会被识别！**</font>

#### 3.6.4. v-show

`v-show` 是另一个用于根据条件展示元素的指令。*与`v-if`指令用法基本一致*

```html
<h1 v-show="ok">Hello!</h1>
```

不同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地将元素的属性 `display: none`。

<font color=red>**注意，`v-show` 不支持 `<template>` 元素，也不支持 `v-else`**</font>

#### 3.6.5. v-if 与 v-show 区别

实现原理不同：

- `v-if` 指令会动态地创建或移除 DOM 元素，从而控制元素在页面上的显示与隐藏；是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。此指令也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
- `v-show` 指令会动态为元素添加或移除 `style="display: none;"` 样式，从而控制元素的显示与隐藏。不管初始条件是什么，元素总是会被渲染

性能消耗不同。`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此：

- 如果需要非常频繁地切换，则使用 `v-show` 较好
- 如果在运行时条件很少改变，则使用 `v-if` 较好

#### 3.6.6. v-if 与 v-for 一起使用

不推荐在同一元素上同时使用 `v-if` 和 `v-for`。当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。

### 3.7. 列表渲染指令

vue 提供了 `v-for` 列表渲染指令，用来基于一个数组来循环渲染一个列表结构。

#### 3.7.1. v-for 循环数组

用 `v-for` 指令基于一个数组来渲染一个列表。

语法：

```
v-for="(item, index) in items"
```

参数解析：

- `items` 是源数据数组。（*变量是data中定义*）
- 第1个参数`item` 是被迭代的数组元素的别名。
- 第2个参数`index` 是被迭代当前项的索引。

> 注意：`v-for` 指令中的 `item` 项和 `index` 索引都是形参，可以根据需要进行重命名。

示例：

```html
<li v-for="(item, index) in items" :key="index">
  {{ item.message }} :: {{ index }}
</li>
```

<font color=red>也可以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法</font>：

```html
<div v-for="item of items"></div>
```

#### 3.7.2. v-for 循环对象

可以用 `v-for` 来遍历一个对象的 property 属性。*其语法使用与循环数组一致*

```html
<!--
    第1个参数是对象的属性值；
    第2个的参数为 property 名称 (也就是键名)
    第3个的参数为索引
 -->
<ul>
  <li v-for="(value, name, index) in obj" :key="name">
    属性值：{{ value }} | 属性名：{{ name }} | 索引值：{{ index }}
  </li>
</ul>
```

> 注意：在遍历对象时，会按 `Object.keys()` 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。

#### 3.7.3. v-for 里使用值范围（整数）

`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。

```html
<div>
  <span v-for="n in 10" :key="n">{{ n }} </span>
</div>
```

输出结果：

```
1 2 3 4 5 6 7 8 9 10
```

#### 3.7.4. 在 template 标签上使用 v-for

利用带有 `v-for` 的 `<template>` 来循环渲染一段包含多个元素的内容。

```html
<ul>
  <template v-for="(item, index) in items">
    <li :key="'A' + index">{{ item.message }}</li>
    <li :key="'B' + index" style="color: red">{{ index }}</li>
  </template>
</ul>
```

#### 3.7.5. 在组件上使用 v-for (待整理！)


#### 3.7.6. 使用 key 维护列表的状态

当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。

当列表的数据变化时，默认情况下，vue 会尽可能的复用已存在的 DOM 元素，从而提升渲染的性能。但这种默认的性能优化策略，会导致有状态的列表无法被正确更新。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，保证有状态的列表被正确更新的前提下，重用和重新排序现有元素，提升渲染的性能。需要为每项提供一个唯一 key 属性：

```html
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
```

> 注：不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key` 值。请用字符串或数值类型的值。

**key 的注意事项总结**：

- key 的值只能是字符串或数字类型
- key 的值必须具有唯一性（即：key 的值不能重复）
- 建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性）
- 使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性）
- 建议使用 `v-for` 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）

#### 3.7.7. 数组更新检测规则

Vue会对一些数组更新的情况，才会触发视图更新。如下可以更新

- **数组变更的方法**会触发视图更新，如：`push()`、`pop()`、`shift()`、`unshift()`、`splice()`、`sort()`、`reverse()`，因为这些方法都会直接改变数组本身。
- **替换数组**会触发视图更新，如：`filter()`、`concat()` 和 `slice()`，是非变更方法，不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：

> 注意事项：由于 JavaScript 的限制，Vue 不能检测数组和对象的变化

#### 3.7.8. 显示过滤/排序后的结果

如想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。

```html
<li v-for="n in evenNumbers">{{ n }}</li>
```

```js
data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
```

在计算属性不适用的情况下 (例如，在嵌套 `v-for` 循环中) ，可以嵌套一个方法：

```html
<ul v-for="set in sets">
  <li v-for="n in even(set)">{{ n }}</li>
</ul>
```

```js
data: {
  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
```

## 4. 计算属性和侦听器

### 4.1. watch 侦听器

#### 4.1.1. 基础使用

`watch` 自定义的侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。**当需要在数据变化时执行异步或开销较大的操作时**，这个方式是最有用的。

```html
<input v-model.lazy="username" />
```

```js
data() {
  return {
    username: 'admin',
  }
},
// 所有的侦听器，都应该被定义到 watch 节点下
watch: {
  /**
   * 侦听器本质上是一个函数，要监视哪个数据的变化，监听的属性名作为函数名
   * 参数1是新值，参数2是旧值
   */
  username(newVal, oldVal) {
    console.log('新值 ==> ', newVal)
    console.log('旧值 ==> ', oldVal)
  },
},
```

#### 4.1.2. 侦听器的配置方式

侦听器取值类型：`{ [key: string]: string | Function | Object | Array }`

侦听器的键是需要观察（被监听）的属性名的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象，或者是包含多个回调函数的数组。

选项的对象可选值：

| 选项对象属性值 |                                                                           说明                                                                           |
| :----------: | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
|  `handler`   | 相应监听变化的回调函数                                                                                                                                     |
|    `deep`    | 如果 `watch` 侦听的是一个对象，而对象中的属性值发生了变化，则无法被监听到。如设置为`true`，则表示该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 |
| `immediate`  | 默认情况下，组件在初次加载完毕后不会调用 `watch` 侦听器。如此属性设置为`true`，则开始侦听对象时就执行回调函数，无论被监听元素是否有变化                               |

使用示例：

```js
watch: {
  a: function (val, oldVal) {
    console.log('new: %s, old: %s', val, oldVal)
  },
  // 方法名
  b: 'someMethod',
  // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深
  c: {
    handler: function (val, oldVal) { /* ... */ },
    deep: true
  },
  // 该回调将会在侦听开始之后被立即调用
  d: {
    handler: 'someMethod',
    immediate: true
  },
  // 你可以传入回调数组，它们会被逐一调用
  e: [
    'handle1',
    function handle2 (val, oldVal) { /* ... */ },
    {
      handler: function handle3 (val, oldVal) { /* ... */ },
      /* ... */
    }
  ],
  // watch vm.e.f's value: {g: 5}
  'e.f': function (val, oldVal) { /* ... */ }
}
```

> <font color=red>**注意，不应该使用箭头函数来定义 `watcher` 函数 (例如 `searchQuery: newValue => this.updateAutocomplete(newValue))`。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.updateAutocomplete` 将是 `undefined`。**</font>

### 4.2. computed 计算属性

#### 4.2.1. 什么是计算属性

计算属性指的是通过一系列运算之后，最终得到一个属性值。这个动态计算出来的属性值可以被模板结构或 methods 方法使用。

所以，对于任何复杂逻辑，都应当使用计算属性。

#### 4.2.2. 计算属性的特点

- 虽然计算属性在声明的时候被定义为方法，但是<font color=red>计算属性的本质是一个属性</font>
- 计算属性会缓存计算的结果，只有计算属性依赖的数据变化时，才会重新进行运算

#### 4.2.3. 基础示例

```html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

```js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

以上示例声明了一个计算属性 `reversedMessage`。在 `computed` 属性中提供的函数将用作 property `vm.reversedMessage` 的 `getter` 函数：

```js
console.log(vm.reversedMessage) // => 'olleH'
vm.message = 'Goodbye'
console.log(vm.reversedMessage) // => 'eybdooG'
```

可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 `vm.reversedMessage` 依赖于 `vm.message`，因此当 `vm.message` 发生改变时，所有依赖 `vm.reversedMessage` 的绑定也会更新。而且是以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。

#### 4.2.4. 计算属性缓存 vs 方法

计算属性其实同样可以通过函数的方式来实现计算的功能。

```html
<p>Reversed message: "{{ reversedMessage() }}"</p>
```

```js
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

与定义方法不同的是，<font color=red>计算属性是基于它们的响应式依赖进行缓存的</font>。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。

相比之下，定义方法的方式，每当触发重新渲染时，调用方法将总会再次执行函数。*但如果不希望有缓存，则使用方法方式来替代计算属性*。

#### 4.2.5. 计算属性 vs 侦听属性

Vue 另一种更通用的方式来观察和响应 Vue 实例上的数据变动是：侦听属性。当有一些涉及多个数据需要随着其它们数据变动而变动时，假如使用 `watch` 侦听去处理，则需要各自设置方法去进行侦听多个属性，然而使用计算属性，则只需要定义一个即可。如下：

```html
<div id="demo">{{ fullName }}</div>
```

```js
// 侦听器方式
watch: {
  firstName: function (val) {
    this.fullName = val + ' ' + this.lastName
  },
  lastName: function (val) {
    this.fullName = this.firstName + ' ' + val
  }
}

// 计算属性方式
computed: {
  fullName: function () {
    return this.firstName + ' ' + this.lastName
  }
}
```

#### 4.2.6. 计算属性的 setter

计算属性默认只有 `getter` 方法，不过在需要时也可以自定义提供一个 `setter` 方法

```js
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    },
  },
},
```


## 5. 过滤器

过滤器（Filters）是 vue 提供的功能，常用于文本的格式化。过滤器可以用在两个地方：**双花括号插值表达式和 `v-bind` 属性绑定指令**(后者从 2.1.0+ 开始支持)。

### 5.1. 过滤器的使用

过滤器应该被添加在 JavaScript 表达式的尾部，由“**管道符**”进行调用。语法如下：

```html
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

### 5.2. 自定义过滤器

#### 5.2.1. 私有过滤器（局部过滤器）

可以在 `filters` 节点中定义过滤器。在 filters 节点下定义的过滤器，称为“私有过滤器/局部过滤器”，因为它只能在当前 vm 实例所控制的 el 区域内使用。

```js
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```

#### 5.2.2. 全局过滤器

如果希望在多个 vue 实例之间共享过滤器，则需要在创建 Vue 实例之前全局定义过滤器。语法格式如下：

```js
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```

<font color=red>**注意：当全局过滤器和局部过滤器重名时，会优先使用局部过滤器。**</font>


### 5.3. 过滤器串联调用

过滤器可以串联地进行调用

```html
{{ message | filterA | filterB }}
```

在这个例子中，`filterA` 被定义为接收单个参数的过滤器函数，表达式 `message` 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 `filterB`，将 `filterA` 的结果传递到 `filterB` 中。

### 5.4. 过滤器接收参数

过滤器的本质是 JavaScript 函数，因此可以接收参数：

```html
{{ message | filterA('arg1', arg2) }}
```

以上示例，`filterA` 被定义为接收三个参数的过滤器函数。其中 `message` 的值作为第一个参数，普通字符串 `'arg1'` 作为第二个参数，表达式 `arg2` 的值作为第三个参数。

<font color=red>**注意：过滤器函数的第1个参数永远都是“管道符”前面待处理数值**</font>

### 5.5. 过滤器的兼容性

**过滤器仅在 vue 2.x 和 1.x 中受支持，在 vue 3.x 的版本中剔除了过滤器相关的功能**。在企业级项目开发中：

- 如果使用的是 2.x 版本的 vue，则依然可以使用过滤器相关的功能
- 如果项目已经升级到了 3.x 版本的 vue，官方建议使用计算属性或方法代替被剔除的过滤器功能

> 具体的迁移指南，请参考 vue 3.x 的官方文档给出的说明：https://v3.vuejs.org/guide/migration/filters.html#migration-strategy



