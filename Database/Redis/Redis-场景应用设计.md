## 1. （待整理）实现限流

> TODO: 待整理

## 2. (待整理)解决分布式锁的框架 - Redisson

### 2.1. redis 实现分布式锁概述

Redis 实现分布式锁主要利用 `setnx` 命令。`setnx` 是 SET if not exists(如果不存在，则直接 SET)的简写。

- 获取锁：

```shell
# 添加锁，NX是互斥、EX是设置超时时间
SET lock value NX EX 10
```

> Notes: 直接使用 `setnx` 命令与上例，而 `setnx` 是相当于两条命令，而上例为单条命令，可以保证原子性。

- 释放锁：

```shell
# 释放锁，删除即可
DEL key
```

#### 2.1.1. 分布式锁流程图

![](images/331765216230846.png)

#### 2.1.2. Redis 如何合理的控制分布式锁有效时长

- 根据业务执行时间预估
- 给锁续期

### 2.2. Redisson 简介

> 官网：https://redisson.org/

Redisson 是与 Jedis 很相似的用于操作 Redis 的框架，其中实现一个功能是在高并发的情况，给 Redis 加上锁，并且在线程的执行过程中，判断当前线程是否已经执行结束，会自动给当前的锁增加存活时间，以便让当前线程完全执行后，再去释放锁。

### 2.3. Redisson 实现分布式锁

#### 2.3.1. 执行流程

![](images/586250517237139.jpg)

在 redisson 中需要手动加锁，并且可以控制锁的失效时间和等待时间。在 redisson 中引入了一个看门狗机制，当锁住的一个业务还没有执行完成的时候，会自动每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了。

redisson 还实现了在高并发下，一个业务有可能会执行很快，先线程1持有锁的时候，线程2来了以后并不会马上拒绝，它会自旋不断尝试获取锁；如果线程1释放之后，线程2就可以马上持有锁，性能也得到了提升。

#### 2.3.2. 分布式锁的可重入性

Redisson 实现的分布式锁是可重入的，此设计为了避免死锁的产生。

可重入的具体实现是，在内部判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减1。在存储数据的时候采用的 hash 结构<font color=red>**记录线程id 和重入次数**</font>。

![](images/245122218249974.png)

> 其中键可以按照业务进行定制，hash 结构的值的小 key 是当前线程的唯一标识，value 是当前线程重入的次数。

示例：

```java
public void add1() {
    RLock lock = redissonClient.getLock("moon_lock");
    boolean isLock = lock.tryLock();
    // 执行业务
    add2();
    // 释放锁
    lock.unlock();
}

public void add2() {
    RLock lock = redissonClient.getLock("moon_lock");
    boolean isLock = lock.tryLock();
    // 执行业务
    // 释放锁
    lock.unlock();
}
```

#### 2.3.3. 分布式锁的主从一致性问题

redisson 实现的分布式锁无法解决主从一致性问题。比如，当线程1加锁成功后，master 节点数据会异步复制到 slave 节点，此时当前持有 Redis 锁的 master 节点宕机，slave 节点被提升为新的 master 节点，假如现在来了一个线程2，再次加锁，会在新的 master 节点上加锁成功，此时就会出现两个节点同时持有一把锁的问题。

可以利用 redisson 提供的 RedLock（红锁）来解决主从一致性问题。它的主要作用是，不只在一个 redis 实例上创建锁，而是在多个 redis 实例(n / 2 + 1)上创建锁，并且要求在大多数 redis 节点上都成功创建锁，红锁中要求是 redis 的节点数量要过半。这样就能避免线程1 加锁成功后 master 节点宕机导致线程2 成功加锁到新的 master 节点上的问题了。

但是使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁。

> Tips: Redis 是支持高可用的，若要实现强一致性，则非常影响性能。所以强一致性要求高的业务，建议使用 zookeeper 实现的分布式锁，它是可以保证强一致性的。

### 2.4. 使用示例

分布式锁-案例：

![](images/20190418230705829_26455.png)

![](images/62391017257305.png)

## 3. （待研究）分布式锁 - RedLock

Redlock 是官方权威提出的基于 Redis 实现分布式锁的方式，此种方式比原先的单节点的方法更安全。它可以保证以下特性：

1. 安全特性：互斥访问，即永远只有一个 client 能拿到锁
2. 避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client 挂掉了
3. 容错性：只要大部分 Redis 节点存活就可以正常提供服务
