# 03-用户登陆与认证授权

## 1. 传统用户登陆实现方式

注册功能完成，接着需要实现登录功能。传统实现方式的思路：查询数据库，确定账号和密码是否存在(正确)。

### 1.1. 定义请求方法

在 wanxinp2p-api 工程的 `AccountAPI` 接口中定义登录方法 `login`  与封装请求参数的实体类

```java
@Data
@ApiModel(value = "AccountLoginDTO", description = "账户登录信息")
public class AccountLoginDTO {
    @ApiModelProperty("用户名")
    private String username;
    @ApiModelProperty("手机号")
    private String mobile;
    @ApiModelProperty("密码")
    private String password;
    @ApiModelProperty("域 (c：c端用户；b：b端用户)")
    private String domain;
}
```

```java
/**
 * 用户登录
 *
 * @param accountLoginDTO 封装用户登录信息
 * @return
 */
RestResponse<AccountDTO> login(AccountLoginDTO accountLoginDTO);
```

### 1.2. 业务层功能实现

在 wanxinp2p-account-service 工程业务层 `AccountService` 接口中新增登录方法 `login`，并由 `AccountServiceImpl` 实现类来实现功能

```java
@Override
public AccountDTO login(AccountLoginDTO accountLoginDTO) {
    // 先根据用户名进行查询，然后再比对密码
    Account account = null;
    if (accountLoginDTO.getDomain().equalsIgnoreCase("c")) {
        // 如果是c端用户，用户名就是手机号
        account = getAccountByMobile(accountLoginDTO.getMobile());
    } else {
        // 如果是b端用户，用户名就是账号
        account = getAccountByUsername(accountLoginDTO.getUsername());
    }
    if (account == null) {
        // 用户不存在，抛出业务异常
        throw new BusinessException(AccountErrorCode.E_130104);
    }

    AccountDTO accountDTO = new AccountDTO();
    BeanUtils.copyProperties(account, accountDTO);
    if (smsEnable) {
        // 如果为true，表示采用短信验证码登录，无需比较密码
        return accountDTO;
    }
    // 验证密码
    if (PasswordUtil.verify(accountLoginDTO.getPassword(), account.getPassword())) {
        return accountDTO;
    }

    throw new BusinessException(AccountErrorCode.E_130105);
}

/**
 * 根据用户名获取账户信息
 */
private Account getAccountByUsername(String username) {
    return this.getOne(new QueryWrapper<Account>().lambda().eq(Account::getUsername, username)
}

/**
 * 根据手机号获取账户信息
 */
private Account getAccountByMobile(String mobile) {
    return this.getOne(new QueryWrapper<Account>().lambda().eq(Account::getMobile, mobile));
}
```

### 1.3. 控制层实现

修改 `AccountController` 类，实现接口的 `login` 方法

```java
@ApiOperation("用户登录")
@ApiImplicitParam(name = "accountLoginDTO", value = "登录信息",
        required = true, dataType = "AccountLoginDTO", paramType = "body")
@PostMapping(value = "/l/accounts/session")
@Override
public RestResponse<AccountDTO> login(AccountLoginDTO accountLoginDTO) {
    return RestResponse.success(accountService.login(accountLoginDTO));
}
```

### 1.4. 存在问题

传统登录实现方式在应付分布式、微服务场景时存在的问题：

- 每个微服务都要进行登录校验，但项目通常都需要单点登录
- 不同微服务间的会话保持问题
- 认证方式单一，无法适应各种认证场景（如：扫码，指纹...），毫无扩展性

## 2. UAA 认证服务

### 2.1. 概述

P2P 平台作为网络贷款平台，采用了前后端分离、分布式、微服务等架构，这就决定了传统的登录实现方式无法满足登陆认证的需求。为了解决这个问题，要在 P2P 平台引入独立的 UAA 服务。 UAA 全称是 User Account and Authentication，简称为认证服务，UAA 服务使用 Spring Security+Oauth2+JWT 技术栈实现，结合前面的网关服务(gateway)来完成 P2P 平台的认证和授权业务功能。

### 2.2. 什么是认证、授权、会话

**认证(authentication)** ：用户认证即用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证形式有：账号密码登录，二维码登录，手机短信登录，指纹认证等方式。

**授权(authorization)**：用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫授权。

**会话(session)** ：会话是指用户登入系统后，系统会记住该用户的登录状态，他可以在系统连续操作直到登出的过程。

## 3. 数据安全

### 3.1. 概述

为了保证数据安全，需要解决三个问题：机密性、完整性、身份验证（抗抵赖性）

- 机密性：传输内容非明文，即使数据被外界截获，也不能被他人解释或破解。
- 完整性：传输过程中内容不能够被篡改，若信息被篡改或不完整，接收方能够得知。
- 身份验证（抗抵赖性）：接收方能够验证数据的实际发送方，确保数据不是被人“冒名顶替”而伪造的。

### 3.2. 机密性

**机密性**可通过**加密算法**保证，加密算法定义了明文、密文之间如何转换，也就是加解密的过程。加密算法分为：**对称加密**和**非对称加密**。

#### 3.2.1. 对称加密算法

对称加密指加密和解密使用**相同密钥**的加密算法。有时又叫传统密码算法，就是加密秘钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是**相同的**，所以也称这种加密算法为秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信性至关重要。

常见的对称加密算法主要有 DES，AES，3DES、RC2、RC4 和 RC5 等。

#### 3.2.2. 非对称加密算法

如果加密和解密使用的是两个不同的密钥，这种算法叫作**非对称加密算法**。非对称加密算法需要**两个密钥**：公开密钥(`public key`)和私有密钥(`private key`)，公开密钥与私有密钥是一对。

- 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密
- 如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密

非对称加密算法实现机密信息交换的基本过程是：

- 甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开
- 得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方
- 甲方再用自己保存的另一把专用密钥对加密后的信息进行解密

常见的非对称加密算法：RSA、DSA、ECC 等。

#### 3.2.3. RSA 算法示例

```java
public class RSAEncrypt {

    final static Base64.Decoder decoder = Base64.getDecoder();
    final static Base64.Encoder encoder = Base64.getEncoder();

    /**
     * RSA公钥加密
     *
     * @param str       加密字符串
     * @param publicKey 公钥
     * @return 密文
     * @throws Exception 加密过程中的异常信息
     */
    public static String encrypt(String str, String publicKey) throws Exception {
        // base64编码的公钥
        byte[] decoded = decoder.decode(publicKey);
        RSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance("RSA")
                .generatePublic(new X509EncodedKeySpec(decoded));
        // RSA加密
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.ENCRYPT_MODE, pubKey);
        String outStr = encoder.encodeToString(cipher.doFinal(str.getBytes(StandardCharsets.UTF_8)));
        return outStr;
    }

    /**
     * RSA私钥解密
     *
     * @param str        加密字符串
     * @param privateKey 私钥
     * @return 明文
     * @throws Exception 解密过程中的异常信息
     */
    public static String decrypt(String str, String privateKey) throws Exception {
        // base64解码后的字符串
        byte[] inputByte = decoder.decode(str.getBytes(StandardCharsets.UTF_8));
        // base64编码的私钥
        byte[] decoded = decoder.decode(privateKey);
        RSAPrivateKey priKey = (RSAPrivateKey) KeyFactory.getInstance("RSA")
                .generatePrivate(new PKCS8EncodedKeySpec(decoded));
        // RSA解密
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, priKey);
        String outStr = new String(cipher.doFinal(inputByte));
        return outStr;
    }

    /**
     * 生成密钥对
     *
     * @return 公私钥对
     * @throws Exception
     */
    public static KeyPair getKeyPair() throws Exception {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        // 可以理解为：加密后的密文长度，实际原文要小些 越大 加密解密越慢
        keyGen.initialize(512);
        KeyPair keyPair = keyGen.generateKeyPair();
        return keyPair;
    }

    public static Map<Integer, String> genKeyPair() throws Exception {
        Map<Integer, String> keyMap = new HashMap<>();
        // 生成公私钥对
        KeyPair keyPair = getKeyPair();
        PublicKey publicKey = keyPair.getPublic();
        PrivateKey privateKey = keyPair.getPrivate();

        String publicKeyString = encoder.encodeToString(publicKey.getEncoded());
        // 得到私钥字符串
        String privateKeyString = encoder.encodeToString(privateKey.getEncoded());
        // 将公钥和私钥保存到Map
        keyMap.put(0, publicKeyString);  // 0表示公钥
        keyMap.put(1, privateKeyString);  // 1表示私钥
        return keyMap;
    }

    /**
     * 测试RSA加解密
     */
    public static void main(String[] args) throws Exception {
        Map<Integer, String> keyMap = RSAEncrypt.genKeyPair();
        String content = "天锁斩月";
        System.out.println("随机生成的公钥为:" + keyMap.get(0));
        System.out.println("随机生成的私钥为:" + keyMap.get(1));
        String messageEn = RSAEncrypt.encrypt(content, keyMap.get(0));
        System.out.println("加密后的字符串为:" + messageEn);
        String messageDe = RSAEncrypt.decrypt(messageEn, keyMap.get(1));
        System.out.println("解密后的字符串为:" + messageDe);
    }
}
```

### 3.3. 完整性

#### 3.3.1. 概述

信息**完整性**可通过提取并对比**消息摘要**的方式来实现。**消息摘要**就是根据一定的运算规则对原始数据进行某种形式的信息提取，通过消息摘要后的消息摘要的长度总是固定的，它也叫做数据指纹，因为它可以唯一的标识一段数据。

常见的摘要算法有：sha1、sha256、md5、crc32 等。

#### 3.3.2. SHA256 摘要算法示例

```java
public class SHA256 {

    /**
     * 实现SHA256加密
     *
     * @param str 加密后的报文
     * @return
     */
    public static String getSHA256(String str) {
        MessageDigest messageDigest;
        String encodestr = "";
        try {
            messageDigest = MessageDigest.getInstance("SHA-256");
            messageDigest.update(str.getBytes(StandardCharsets.UTF_8));
            encodestr = byte2Hex(messageDigest.digest());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return encodestr;
    }

    private static String byte2Hex(byte[] bytes) {
        StringBuffer stringBuffer = new StringBuffer();
        String temp = null;
        for (int i = 0; i < bytes.length; i++) {
            temp = Integer.toHexString(bytes[i] & 0xFF);
            if (temp.length() == 1) {
                stringBuffer.append("0");
            }
            stringBuffer.append(temp);
        }
        return stringBuffer.toString();
    }

    /**
     * 测试SHA256摘要算法
     */
    public static void main(String[] args) {
        String content = "死亡笔记";
        System.out.println(content + ": 第一次摘要后的字符串为:" + SHA256.getSHA256(content));
        content = "言叶之庭"; // 模拟数据被窜改，两次加密后结果不一样的
        System.out.println(content + ": 第二次摘要后的字符串为:" + SHA256.getSHA256(content));
    }
}
```

#### 3.3.3. 小结

从上面的内容可以了解到**摘要算法**的特性，发送方和接收方可以约定使用**相同**的**摘要算法**对原文进行摘要运算，双方得出的**消息摘要**若一致，说明数据在传输过程中没有被篡改。

### 3.4. 身份验证

#### 3.4.1. 概述

即使保证了数据的机密性和完整性，这里面仍然存在一些问题：

- **接收方**若要验证消息完整性，必须得到**发送方**对消息产生的摘要，若第三方得知**摘要算法**，那摘要也是可以被伪造的，因此摘要本身也需要被加密。
- 消息发送来源如何确定，怎么确定不是第三方伪造的？

发送方将消息原文使用摘要算法生成摘要，再用私钥对摘要进行加密，生成**数字签名**，然后将内容附上数字签名一起传输。

![](images/584045215238688.png)

接收方收到消息后，用发送方的公钥对数字签名进行解密(能解密成功就完成了对发送方的身份验证)，得到摘要A，然后再对原文使用摘要算法生成摘要B，比对摘要A和B是否相同，相同则说明内容没有被篡改。

![](images/359605515226555.png)


#### 3.4.2. 示例

此示例使用 SHA1 作为摘要算法，使用 RSA 作为签名加密算法的签名及验签过程，在 `RSAEncrypt.java` 中增加以下代码：

```java
public static final String SIGN_ALGORITHMS = "SHA1WithRSA";

/**
 * RSA签名
 *
 * @param content       待签名数据
 * @param privateKey    私钥
 * @param input_charset 编码格式
 * @return 签名值
 */
public static String sign(String content, String privateKey, String input_charset) {
    try {
        PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(decoder.decode(privateKey));
        KeyFactory keyf = KeyFactory.getInstance("RSA");
        PrivateKey priKey = keyf.generatePrivate(priPKCS8);
        Signature signature = Signature.getInstance(SIGN_ALGORITHMS);
        signature.initSign(priKey);
        signature.update(content.getBytes(input_charset));
        byte[] signed = signature.sign();
        return encoder.encodeToString(signed);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

/**
 * RSA验签名检查
 *
 * @param content       待签名数据
 * @param sign          签名值
 * @param public_key    公钥
 * @param input_charset 编码格式
 * @return 布尔值
 */
public static boolean verify(String content, String sign, String public_key, String input_charset) {
    try {
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        byte[] encodedKey = decoder.decode(public_key);
        PublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));
        Signature signature = Signature.getInstance(SIGN_ALGORITHMS);
        signature.initVerify(pubKey);
        signature.update(content.getBytes(input_charset));
        return signature.verify(decoder.decode(sign));
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}
```

测试签名、验证签名

```java
@Test
public void testSHA1WithRSA() throws Exception {
    Map<Integer, String> akeyMap = RSAEncrypt.genKeyPair(); // a方密钥对
    System.out.println("随机生成的a方公钥为:" + akeyMap.get(0));
    System.out.println("随机生成的a方私钥为:" + akeyMap.get(1));

    String content = "金田一少年之事件簿";

    System.out.println("------------ a向b发送数据，使用a的私钥生成签名 -----------");
    String signature = RSAEncrypt.sign(content, akeyMap.get(1), "utf-8");
    System.out.println("原文:'" + content + "'生成签名：" + signature);

    System.out.println("---------- b接收到a发的数据，使用a的公钥验证签名 -----------");
    if (RSAEncrypt.verify(content, signature, akeyMap.get(0), "utf-8")) {
        System.out.println("验证签名成功：" + signature);
    } else {
        System.out.println("验证签名失败！");
    }
}
```

### 3.5. 总结

- 通过**加密算法**对数据原文的加密、解密，能保证数据传输过程中的**机密性**。
- 通过**数字签名**机制，既可以保证数据**完整性**，也可以对数据来源进行**身份验证**。
- 针对**非对称加密技术**的应用，通常使用两种方式：
    - **传输过程中的数据加密**，使用接收方公钥加密，接收方私钥解密，保证数据在传输过程中是密文。
    - **接收方对信息来源的确认**，发送方会使用私钥对数据签名，接收方使用发送方公钥进行验签。

## 4. 用户认证机制
  
用户认证表面上看只是系统校验用户名（身份）、密码（凭证）的过程。但是为了会话保持，提高安全性，适应不同系统架构以及各种各样的认证方式（用户名、密码，二维码，短信，三方认证，单点登录...），认证的机制也在不断演进，传统的账号密码登录变成了只是认证方式中的一种。

### 4.1. 基于 Session 认证

目前大多数 web 应用的用户认证机制都是基于 session 的。用户认证成功后，在服务端生成用户相关的数据保存在 session中(当前会话)，而发给客户端的 sesssion_id 存放到 cookie 中，这样用客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据，以此完成用户的合法校验。当用户登出或过期时就将服务端 session 销毁，客户端的 session_id 也就无效了。

![](images/500291416246721.png)

而在分布式的环境下，基于 session 的认证会出现一个问题。当第一次访问网站的时候，负载均衡将本地的请求分配到 Web 服务器A，那么 session 创建在 Web 服务器A，第二次访问的时候，如果不做处理就不能保证还是会落到 Web 服务器A了。此时，通常的做法有下面几种：

- **Session复制**：多台应用服务器之间同步 session，使 session 保持一致，对外透明
- **Session粘滞**：当用户访问集群中某台服务器后，强制指定后续所有请求均落到此机器上
- **Session数据集中存储**：将 Session 存入分布式缓存集群中，所有服务器应用实例统一从分布式缓存集群中存取 Session

总体来讲，基于 session 认证的认证方式，可以更好的在服务端对会话进行控制，且安全性较高。但是，session 机制方式基于 cookie，在移动应用上无法有效使用，并且无法跨域，保持会话的做法非常麻烦。

### 4.2. 基于 Token 认证

随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。基于 token 的用户认证是一种服务端无状态的认证方式，所谓服务端无状态指的是 token 本身包含登录用户所有的相关数据，而客户端在认证后的每次请求都会携带 token，因此服务器端无需存放 token 数据。

当用户认证后，服务端生成一个 token 发给客户端，客户端可以放到 cookie 或 localStorage 等存储中，每次请求时带上 token，服务端收到 token 通过验证后即可确认用户身份。

![](images/312982316239390.png)

#### 4.2.1. 什么是 JWT

目前市面上基于 token 的认证方式大都采用的是 JWT(Json Web Token)。

JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递 json 对象，传递的信息经过数字签名可以被验证和信任。

#### 4.2.2. JWT 令牌结构

JWT 令牌由 Header、Payload、Signature 三部分组成，每部分中间使用点（`.`）分隔，比如：`xxxxx.yyyyy.zzzzz`

- **Header**：第一部分是头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC、SHA256或RSA）。

例子：

```json
{
	"alg": "HS256"，
	"typ": "JWT"
}
```

将上边的内容使用 Base64Url 编码，得到一个字符串就是 JWT 令牌的第一部分。

- **Payload**：第二部分是负载，内容也是一个 json 对象，它是存放有效信息的地方，它可以存放 jwt 提供的现成字段，比如：iss（签发者），exp（过期时间戳）， sub（面向的用户）等，也可自定义字段。此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。

例子：

```json
{
	"sub": "1234567890"，
	"name": "456"，
	"admin": true
}
```

最后将第二部分负载使用 Base64Url 编码，得到一个字符串就是 JWT令牌的第二部分。

- **Signature**：第三部分是签名，此部分用于防止 JWT 内容被篡改。这个部分使用 base64url 将前两部分进行编码，编码后使用点（`.`）连接组成字符串，最后使用 header 中声明签名算法进行签名。

例子：

```java
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload)，secret)
```

- base64UrlEncode(header)：jwt令牌的第一部分。
- base64UrlEncode(payload)：jwt令牌的第二部分。
- secret：签名所使用的密钥。

> 怎么保证令牌的安全？非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。公钥是密钥对中公开的部分，私钥则是非公开的部分，通过这种算法得到的密钥对能保证在世界范围内是唯一的 。用公钥加密的数据只有对应的私钥才可以解密

#### 4.2.3. JWT 令牌优缺点

**JWT令牌的优点：**

1. JWT 基于 json，非常方便解析。
2. 可以在令牌中自定义丰富的内容，易扩展。
3. 基于 token 认证这种方式服务端不用存储认证数据，易维护，扩展性强， token 存在 localStorage 可避免 CSRF，并且可以实现 web 和 app 统一认证机制。
4. 通过非对称加密算法及数字签名技术，JWT 防止篡改，安全性高。

**JWT令牌的缺点：**

token 由于自包含信息，因此一般数据量较大，而且每次请求都需要传递，因此比较占带宽。另外，token 的签名验签操作也会给 cpu 带来额外的负担。但是随着硬件的提升和带宽的提高，这些缺点变得越来越微不足道。

### 4.3. OAuth2.0 认证

#### 4.3.1. 概述

OAuth（开放授权）是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。OAuth2.0 是 OAuth 协议的延续版本，但不兼容 OAuth 1.0（即完全废止了 OAuth1.0）。

#### 4.3.2. OAuth2.0 场景

> 此部分内容详见《授权认证概述》笔记中的 [OAuth2.0 协议的认证流程示例](/02-后端框架/07-Authorization-Certification/00-Authorization-Overview?id=_42-oauth20-协议的认证流程示例)












