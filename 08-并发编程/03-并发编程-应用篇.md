# 并发编程-应用篇

## 1. 限制对 CPU 的使用

限制 CPU 高占用率。

### 1.1. sleep 实现

在没有利用 cpu 来计算时，让 `while(true)` 空转会浪费 cpu，这时可以使用 `yield` 或 `sleep` 来让出 cpu 的使用权给其他程序，从而减少cpu占用率

```java
while (true) {
    try {
        /*
         * 在没有利用 cpu 来计算时，让 while(true) 空转会浪费 cpu，
         * 这时可以使用 yield 或 sleep 来让出 cpu 的使用权给其他程序，
         * 从而减少cpu占用率
         */
        Thread.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

- 可以用 `wait` 或条件变量达到类似的效果
- 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景
- `sleep` 适用于无需锁同步的场景

### 1.2. wait 实现

```java
synchronized(锁对象) {
    while(条件不满足) {
        try {
            锁对象.wait();
        } catch(InterruptedException e) {
            e.printStackTrace();
        }
    }
    // do something...
}
```

### 1.3. 条件变量实现

```java
lock.lock();
try {
    while(条件不满足) {
        try {
            条件变量.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    // do something...
} finally {
    lock.unlock();
}
```

## 2. 限制对共享资源的使用


# 并发编程-模式篇

## 1. 终止模式之两阶段终止模式

两个不同的线程，如何让一个线程停止另一个线程，并且让停止的线程完成一些停止前的操作。

### 1.1. 方案1：利用 isInterrupted 打断标识

调用线程的 `interrupt` 方法可以打断正在执行的线程，无论线程是`sleep`、`wait`，还是正常运行。值得注意，如果线程在休眠状态，打断标识会被清除。

```java
public static void main(String[] args) throws InterruptedException {
    System.out.println("程序开始....");
    // 方案1：利用 isInterrupted 打断标识
    useIsInterrupted();
    System.out.println("程序结束....");
}

// 方案1：利用 isInterrupted 打断标识
public static void useIsInterrupted() throws InterruptedException {
    Thread t = new Thread(() -> {
        while (true) {
            Thread current = Thread.currentThread();
            if (current.isInterrupted()) {
                System.out.println("收到结束指示，进行结束前处理！");
                break;
            }
            try {
                // 注意：当sleep状态被打断后，打断标识会被清除，所以异常捕获后要手动再次进行打断，因为运行时打断不会清除打断标识
                Thread.sleep(1000);
                System.out.println("线程的业务处理....");
            } catch (InterruptedException e) {
                current.interrupt();
            }

        }
    }, "监控线程");
    t.start();

    Thread.sleep(3500);
    // 打断线程
    t.interrupt();
}
```

### 1.2. 方案2：自定义停止标记

```java
private static boolean stop = false;

public static void main(String[] args) throws InterruptedException {
    System.out.println("程序开始....");
    // 方案2：自定义停止标记
    useCustomFlag();
    System.out.println("程序结束....");
}

// 方案2：自定义停止标记
public static void useCustomFlag() throws InterruptedException {
    Thread t = new Thread(() -> {
        while (true) {
            if (stop) {
                System.out.println("收到结束指示，进行结束前处理！");
                break;
            }
            try {
                Thread.sleep(1000);
                System.out.println("线程的业务处理....");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, "监控线程");
    t.start();

    Thread.sleep(3500);
    // 打断线程并设置标识为true
    t.interrupt();
    stop = true;
}
```



